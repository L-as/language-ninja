-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A library for dealing with the Ninja build language.
--   
--   A Haskell library for parsing, pretty-printing, and compiling the
--   Ninja build language. The best place to start reading this
--   documentation is the <a>Language.Ninja</a> module.
@package language-ninja
@version 0.0.1


-- | A data type for integers greater than zero.
module Language.Ninja.Misc.Positive

-- | This type represents a positive number; i.e.: an integer greater than
--   zero.
data Positive

-- | Constructor for a <a>Positive</a>.
makePositive :: Int -> Maybe Positive

-- | A <a>Getter</a> for the <a>Int</a> underlying a <a>Positive</a>.
fromPositive :: Getter Positive Int
instance Data.Aeson.Types.FromJSON.FromJSON Language.Ninja.Misc.Positive.Positive
instance Data.Aeson.Types.ToJSON.ToJSON Language.Ninja.Misc.Positive.Positive
instance Control.DeepSeq.NFData Language.Ninja.Misc.Positive.Positive
instance Data.Hashable.Class.Hashable Language.Ninja.Misc.Positive.Positive
instance GHC.Generics.Generic Language.Ninja.Misc.Positive.Positive
instance GHC.Read.Read Language.Ninja.Misc.Positive.Positive
instance GHC.Show.Show Language.Ninja.Misc.Positive.Positive
instance GHC.Enum.Enum Language.Ninja.Misc.Positive.Positive
instance GHC.Real.Integral Language.Ninja.Misc.Positive.Positive
instance GHC.Real.Real Language.Ninja.Misc.Positive.Positive
instance GHC.Classes.Ord Language.Ninja.Misc.Positive.Positive
instance GHC.Classes.Eq Language.Ninja.Misc.Positive.Positive
instance GHC.Num.Num Language.Ninja.Misc.Positive.Positive
instance GHC.Base.Monad m => Test.SmallCheck.Series.Serial m Language.Ninja.Misc.Positive.Positive
instance GHC.Base.Monad m => Test.SmallCheck.Series.CoSerial m Language.Ninja.Misc.Positive.Positive


-- | An interned text type.
module Language.Ninja.Misc.IText

-- | An interned (hash-consed) text type. This is a newtype over
--   <a>InternedText</a> from the <tt>intern</tt> package.
data IText

-- | Get the <a>Text</a> corresponding to the given <a>IText</a> value.
--   
--   <pre>
--   internText (uninternText x) = x
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; uninternText ("foobar" :: IText)
--   "foobar"
--   </pre>
uninternText :: IText -> Text

-- | Intern a <a>Text</a> value, resulting in an <a>IText</a> value.
--   
--   <pre>
--   uninternText (internText x) = x
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; internText ("foobar" :: Text)
--   "foobar"
--   </pre>
internText :: Text -> IText

-- | An <a>Iso'</a> between <a>Text</a> and <a>IText</a>.
--   
--   <pre>
--   ((fromString x) ^. itext) = T.pack x
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (("foobar" :: Text) ^. itext) :: IText
--   "foobar"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (("foobar" :: IText) ^. from itext) :: Text
--   "foobar"
--   </pre>
itext :: Iso' Text IText
instance GHC.Generics.Generic Language.Ninja.Misc.IText.IText
instance Data.String.IsString Language.Ninja.Misc.IText.IText
instance GHC.Classes.Eq Language.Ninja.Misc.IText.IText
instance GHC.Classes.Ord Language.Ninja.Misc.IText.IText
instance GHC.Show.Show Language.Ninja.Misc.IText.IText
instance GHC.Read.Read Language.Ninja.Misc.IText.IText
instance Data.Hashable.Class.Hashable Language.Ninja.Misc.IText.IText
instance Control.DeepSeq.NFData Language.Ninja.Misc.IText.IText
instance Data.Aeson.Types.ToJSON.ToJSON Language.Ninja.Misc.IText.IText
instance Data.Aeson.Types.FromJSON.FromJSON Language.Ninja.Misc.IText.IText
instance Data.Aeson.Types.ToJSON.ToJSONKey Language.Ninja.Misc.IText.IText
instance Data.Aeson.Types.FromJSON.FromJSONKey Language.Ninja.Misc.IText.IText
instance (GHC.Base.Monad m, Test.SmallCheck.Series.Serial m Data.Text.Internal.Text) => Test.SmallCheck.Series.Serial m Language.Ninja.Misc.IText.IText
instance (GHC.Base.Monad m, Test.SmallCheck.Series.CoSerial m Data.Text.Internal.Text) => Test.SmallCheck.Series.CoSerial m Language.Ninja.Misc.IText.IText


-- | A datatype for Unix path strings.
module Language.Ninja.Misc.Path

-- | This type represents a Unix path string.
data Path

-- | Construct a <a>Path</a> from some <a>Text</a>.
makePath :: Text -> Path

-- | An isomorphism between a <a>Path</a> and its underlying <a>IText</a>.
pathIText :: Iso' Path IText

-- | An isomorphism that gives access to a <a>Text</a>-typed view of a
--   <a>Path</a>, even though the underlying data has type <a>IText</a>.
--   
--   This is equivalent to <tt>pathIText . from Ninja.itext</tt>.
pathText :: Iso' Path Text

-- | An isomorphism that gives access to a <a>String</a>-typed view of a
--   <a>Path</a>.
pathString :: Iso' Path String

-- | An isomorphism between a <a>Path</a> and a <a>FilePath</a> from
--   <tt>system-filepath</tt>. This uses <a>decodeString</a> and
--   <a>encodeString</a>, so all the caveats on those functions apply here.
pathFP :: Iso' Path FilePath
instance Data.Aeson.Types.FromJSON.FromJSONKey Language.Ninja.Misc.Path.Path
instance Data.Aeson.Types.ToJSON.ToJSONKey Language.Ninja.Misc.Path.Path
instance Data.Aeson.Types.FromJSON.FromJSON Language.Ninja.Misc.Path.Path
instance Data.Aeson.Types.ToJSON.ToJSON Language.Ninja.Misc.Path.Path
instance Control.DeepSeq.NFData Language.Ninja.Misc.Path.Path
instance Data.Hashable.Class.Hashable Language.Ninja.Misc.Path.Path
instance GHC.Generics.Generic Language.Ninja.Misc.Path.Path
instance Data.String.IsString Language.Ninja.Misc.Path.Path
instance GHC.Read.Read Language.Ninja.Misc.Path.Path
instance GHC.Show.Show Language.Ninja.Misc.Path.Path
instance GHC.Classes.Ord Language.Ninja.Misc.Path.Path
instance GHC.Classes.Eq Language.Ninja.Misc.Path.Path
instance (GHC.Base.Monad m, Test.SmallCheck.Series.Serial m Data.Text.Internal.Text) => Test.SmallCheck.Series.Serial m Language.Ninja.Misc.Path.Path
instance (GHC.Base.Monad m, Test.SmallCheck.Series.CoSerial m Data.Text.Internal.Text) => Test.SmallCheck.Series.CoSerial m Language.Ninja.Misc.Path.Path


-- | A typeclass exposing an interface that allows reading a file from a
--   filesystem (virtual or otherwise).
module Language.Ninja.Mock.ReadFile

-- | This typeclass allows you to write code that reads files from the
--   filesystem and then later run that code purely against a virtual
--   filesystem of some description.
class (Monad m) => MonadReadFile m

-- | Read the file located at the given path and decode it into
--   <a>Text</a>.
--   
--   FIXME: some notion of error handling should be encoded into the type
readFile :: MonadReadFile m => Path -> m Text
instance Language.Ninja.Mock.ReadFile.MonadReadFile GHC.Types.IO
instance (Control.Monad.Trans.Class.MonadTrans t, GHC.Base.Monad (t m), Language.Ninja.Mock.ReadFile.MonadReadFile m) => Language.Ninja.Mock.ReadFile.MonadReadFile (t m)


-- | Typeclasses that allow mocking via dependency injection (i.e.: free
--   monads or similar techniques) in <tt>language-ninja</tt>.
--   
--   This module re-exports all of the modules under the
--   <a>Language.Ninja.Mock</a> namespace for convenience.
--   
--   It is recommended that you import it with the following style:
--   
--   <pre>
--   import qualified Language.Ninja.Mock as Mock
--   </pre>
module Language.Ninja.Mock

-- | This typeclass allows you to write code that reads files from the
--   filesystem and then later run that code purely against a virtual
--   filesystem of some description.
class (Monad m) => MonadReadFile m

-- | Read the file located at the given path and decode it into
--   <a>Text</a>.
--   
--   FIXME: some notion of error handling should be encoded into the type
readFile :: MonadReadFile m => Path -> m Text


-- | Tokenize text into a list of non-whitespace chunks, each of which is
--   annotated with its source location.
module Language.Ninja.Misc.Located

-- | This datatype represents a value annotated with a source location.
data Located t

-- | Given <tt>path :: <a>Maybe</a> <a>Path</a></tt> and a <tt>text ::
--   <a>Text</a></tt>, do the following:
--   
--   <ul>
--   <li>Remove all <tt>'\r'</tt> characters from the <tt>text</tt>.</li>
--   <li>Split the <tt>text</tt> into chunks that are guaranteed not to
--   contain newlines or whitespace, and which are annotated with their
--   location.</li>
--   </ul>
tokenize :: Maybe Path -> Text -> [Located Text]

-- | Read the file at the given <a>Path</a> and then run <a>tokenize</a> on
--   the resulting <a>Text</a>.
tokenizeFile :: (MonadReadFile m) => Path -> m [Located Text]

-- | This function is equivalent to <tt>tokenize Nothing</tt>.
tokenizeText :: Text -> [Located Text]

-- | This function takes the output of <a>tokenize</a> and returns a map
--   from paths to the contents of the associated files.
--   
--   <pre>
--   untokenize [] == Map.empty
--   </pre>
--   
--   <pre>
--   untokenize (xs &lt;&gt; ys) == untokenize xs &lt;&gt; untokenize ys
--   </pre>
--   
--   <pre>
--   untokenize (tokenize (Just path) t) == Map.singleton path t
--   </pre>
--   
--   FIXME: implement
untokenize :: [Located Text] -> Map Path Text

-- | The position of this located value.
locatedPos :: Lens' (Located t) Position

-- | The value underlying this located value.
locatedVal :: Lens' (Located t) t

-- | A type representing a set of source spans.
data Spans

-- | Construct a <a>Spans</a> from a list of <a>Span</a>s.
makeSpans :: [Span] -> Spans

-- | A lens into the <tt><a>HashSet</a> <a>Span</a></tt> underlying a value
--   of type <a>Spans</a>.
spansSet :: Iso' Spans (HashSet Span)

-- | Represents a span of source code.
data Span

-- | Construct a <a>Span</a> from a given start position to a given end
--   position.
makeSpan :: Maybe Path -> Offset -> Offset -> Span

-- | A lens into the (nullable) path associated with a <a>Span</a>.
spanPath :: Lens' Span (Maybe Path)

-- | A lens giving the start and end <a>Offset</a>s associated with a
--   <a>Span</a>.
spanRange :: Lens' Span (Offset, Offset)

-- | A lens into the <a>Offset</a> associated with the start of a
--   <a>Span</a>.
spanStart :: Lens' Span Offset

-- | A lens into the <a>Offset</a> associated with the end of a
--   <a>Span</a>.
spanEnd :: Lens' Span Offset

-- | A getter for the <a>Position</a> associated with the start of a
--   <a>Span</a>.
spanStartPos :: Getter Span Position

-- | A getter for the <a>Position</a> associated with the end of a
--   <a>Span</a>.
spanEndPos :: Getter Span Position

-- | This datatype represents the position of a cursor in a text file.
data Position

-- | Construct a <a>Position</a> from a (nullable) path and a <tt>(line,
--   column)</tt> pair.
makePosition :: Maybe Path -> Offset -> Position

-- | The path of the file pointed to by this position, if any.
positionFile :: Lens' Position (Maybe Path)

-- | The offset in the file pointed to by this position.
positionOffset :: Lens' Position Offset

-- | The line number in the file pointed to by this position.
positionLine :: Lens' Position Line

-- | The column number in the line pointed to by this position.
positionCol :: Lens' Position Column

-- | If two <a>Position</a>s are comparable (i.e.: if they are in the same
--   file), this function will return an <a>Ordering</a> giving their
--   relative positions. Otherwise, it will of course return
--   <a>Nothing</a>.
comparePosition :: Position -> Position -> Maybe Ordering

-- | A line/column offset into a file.
type Offset = (Line, Column)

-- | Compare two <a>Offset</a>s in lexicographic order (i.e.: the
--   <a>Column</a> is ignored unless they are on the same <a>Line</a>).
compareOffset :: Offset -> Offset -> Ordering

-- | A lens into the <a>Line</a> associated with an <a>Offset</a>.
--   
--   For now, this is simply defined as <tt>offsetLine = <a>_1</a></tt>,
--   but if <a>Offset</a> is later refactored to be an abstract data type,
--   using this lens instead of <a>_1</a> will decrease the amount of code
--   that breaks.
offsetLine :: Lens' Offset Line

-- | A lens into the <a>Line</a> associated with an <a>Offset</a>.
--   
--   Read the description of <a>offsetLine</a> for an understanding of why
--   this exists and why you should use it instead of <a>_2</a>.
offsetColumn :: Lens' Offset Column

-- | A line number.
type Line = Int

-- | A column number.
type Column = Int
instance GHC.Show.Show Language.Ninja.Misc.Located.Chunks
instance GHC.Classes.Eq Language.Ninja.Misc.Located.Chunks
instance GHC.Show.Show Language.Ninja.Misc.Located.Chunk
instance GHC.Classes.Eq Language.Ninja.Misc.Located.Chunk
instance Data.Traversable.Traversable Language.Ninja.Misc.Located.Located
instance Data.Foldable.Foldable Language.Ninja.Misc.Located.Located
instance GHC.Base.Functor Language.Ninja.Misc.Located.Located
instance GHC.Generics.Generic (Language.Ninja.Misc.Located.Located t)
instance GHC.Show.Show t => GHC.Show.Show (Language.Ninja.Misc.Located.Located t)
instance GHC.Classes.Eq t => GHC.Classes.Eq (Language.Ninja.Misc.Located.Located t)
instance GHC.Generics.Generic Language.Ninja.Misc.Located.Position
instance GHC.Show.Show Language.Ninja.Misc.Located.Position
instance GHC.Classes.Eq Language.Ninja.Misc.Located.Position
instance Control.DeepSeq.NFData Language.Ninja.Misc.Located.Spans
instance Data.Hashable.Class.Hashable Language.Ninja.Misc.Located.Spans
instance Data.Aeson.Types.FromJSON.FromJSON Language.Ninja.Misc.Located.Spans
instance Data.Aeson.Types.ToJSON.ToJSON Language.Ninja.Misc.Located.Spans
instance GHC.Generics.Generic Language.Ninja.Misc.Located.Spans
instance GHC.Base.Monoid Language.Ninja.Misc.Located.Spans
instance Data.Semigroup.Semigroup Language.Ninja.Misc.Located.Spans
instance GHC.Show.Show Language.Ninja.Misc.Located.Spans
instance GHC.Classes.Eq Language.Ninja.Misc.Located.Spans
instance GHC.Generics.Generic Language.Ninja.Misc.Located.Span
instance GHC.Show.Show Language.Ninja.Misc.Located.Span
instance GHC.Classes.Eq Language.Ninja.Misc.Located.Span
instance Data.Aeson.Types.ToJSON.ToJSON t => Data.Aeson.Types.ToJSON.ToJSON (Language.Ninja.Misc.Located.Located t)
instance Data.Aeson.Types.FromJSON.FromJSON t => Data.Aeson.Types.FromJSON.FromJSON (Language.Ninja.Misc.Located.Located t)
instance Data.Hashable.Class.Hashable t => Data.Hashable.Class.Hashable (Language.Ninja.Misc.Located.Located t)
instance Control.DeepSeq.NFData t => Control.DeepSeq.NFData (Language.Ninja.Misc.Located.Located t)
instance (GHC.Base.Monad m, Test.SmallCheck.Series.Serial m Data.Text.Internal.Text, Test.SmallCheck.Series.Serial m t) => Test.SmallCheck.Series.Serial m (Language.Ninja.Misc.Located.Located t)
instance (GHC.Base.Monad m, Test.SmallCheck.Series.CoSerial m Data.Text.Internal.Text, Test.SmallCheck.Series.CoSerial m t) => Test.SmallCheck.Series.CoSerial m (Language.Ninja.Misc.Located.Located t)
instance (GHC.Base.Monad m, Test.SmallCheck.Series.Serial m (Data.HashSet.HashSet Language.Ninja.Misc.Located.Span)) => Test.SmallCheck.Series.Serial m Language.Ninja.Misc.Located.Spans
instance (GHC.Base.Monad m, Test.SmallCheck.Series.CoSerial m (Data.HashSet.HashSet Language.Ninja.Misc.Located.Span)) => Test.SmallCheck.Series.CoSerial m Language.Ninja.Misc.Located.Spans
instance Data.Aeson.Types.ToJSON.ToJSON Language.Ninja.Misc.Located.Span
instance Data.Aeson.Types.FromJSON.FromJSON Language.Ninja.Misc.Located.Span
instance Data.Hashable.Class.Hashable Language.Ninja.Misc.Located.Span
instance Control.DeepSeq.NFData Language.Ninja.Misc.Located.Span
instance (GHC.Base.Monad m, Test.SmallCheck.Series.Serial m Data.Text.Internal.Text) => Test.SmallCheck.Series.Serial m Language.Ninja.Misc.Located.Span
instance (GHC.Base.Monad m, Test.SmallCheck.Series.CoSerial m Data.Text.Internal.Text) => Test.SmallCheck.Series.CoSerial m Language.Ninja.Misc.Located.Span
instance Data.Aeson.Types.ToJSON.ToJSON Language.Ninja.Misc.Located.Position
instance Data.Aeson.Types.FromJSON.FromJSON Language.Ninja.Misc.Located.Position
instance Data.Hashable.Class.Hashable Language.Ninja.Misc.Located.Position
instance Control.DeepSeq.NFData Language.Ninja.Misc.Located.Position
instance (GHC.Base.Monad m, Test.SmallCheck.Series.Serial m Data.Text.Internal.Text) => Test.SmallCheck.Series.Serial m Language.Ninja.Misc.Located.Position
instance (GHC.Base.Monad m, Test.SmallCheck.Series.CoSerial m Data.Text.Internal.Text) => Test.SmallCheck.Series.CoSerial m Language.Ninja.Misc.Located.Position


-- | A datatype representing a POSIX <tt>sh</tt> command line.
module Language.Ninja.Misc.Command

-- | This type represents a POSIX <tt>sh</tt> command line.
data Command

-- | Constructor for a <a>Command</a>.
makeCommand :: Text -> Command

-- | An isomorphism between a <a>Command</a> and its underlying
--   <a>Text</a>.
commandText :: Iso' Command Text
instance Data.Aeson.Types.FromJSON.FromJSON Language.Ninja.Misc.Command.Command
instance Data.Aeson.Types.ToJSON.ToJSON Language.Ninja.Misc.Command.Command
instance Control.DeepSeq.NFData Language.Ninja.Misc.Command.Command
instance Data.Hashable.Class.Hashable Language.Ninja.Misc.Command.Command
instance GHC.Generics.Generic Language.Ninja.Misc.Command.Command
instance GHC.Read.Read Language.Ninja.Misc.Command.Command
instance GHC.Show.Show Language.Ninja.Misc.Command.Command
instance GHC.Classes.Ord Language.Ninja.Misc.Command.Command
instance GHC.Classes.Eq Language.Ninja.Misc.Command.Command
instance (GHC.Base.Monad m, Test.SmallCheck.Series.Serial m Data.Text.Internal.Text) => Test.SmallCheck.Series.Serial m Language.Ninja.Misc.Command.Command
instance (GHC.Base.Monad m, Test.SmallCheck.Series.CoSerial m Data.Text.Internal.Text) => Test.SmallCheck.Series.CoSerial m Language.Ninja.Misc.Command.Command


-- | A typeclass for AST nodes that are annotated with a polymorphic field,
--   which provides a canonical lens into that field.
module Language.Ninja.Misc.Annotated

-- | If you have some type that represents an AST node, it is often useful
--   to add a polymorphic "annotation field" to it, which is used for
--   things like source positions.
--   
--   Specifically, suppose we have the following AST node type:
--   
--   <pre>
--   data Foo = Foo { _fooBar :: !Bar, _fooBaz :: !Baz } deriving (…)
--   </pre>
--   
--   Then an annotation field is added by the following process:
--   
--   <ol>
--   <li>Add an extra (final) type parameter <tt>ann</tt> to the type.</li>
--   <li>Add an extra field <tt>_fooAnn :: !ann</tt>.</li>
--   <li>Derive instances of <a>Functor</a>, <a>Foldable</a>, and
--   <a>Traversable</a>.</li>
--   <li>If the type is recursive, add a <a>Plated</a> instance. See
--   <a>Language.Ninja.AST.Expr</a> for a complete example of this.</li>
--   <li>Write an <a>Annotated</a> instance with the canonical lens given
--   by the <tt>_fooAnn</tt> field. There are plenty of examples around
--   this library.</li>
--   </ol>
--   
--   The end result then looks like:
--   
--   <pre>
--   data Foo ann
--     = Foo
--       { _fooAnn :: !ann
--       , _fooBar :: !Bar
--       , _fooBaz :: !Baz
--       }
--     deriving (…, Functor, Foldable, Traversable)
--   
--   instance Annotated Foo where
--     annotation' = …
--   </pre>
class (Functor ty) => Annotated (ty :: * -> *)

-- | Given a function that is used when <a>fmap</a>ing any subterms, return
--   a lens into the "annotation" field.
--   
--   When writing an instance, keep in mind that <tt><a>annotation'</a>
--   id</tt> should just be the typical definition for a lens into the
--   annotation field.
--   
--   <pre>
--   annotation' (f . g) == annotation' f . annotation' g
--   </pre>
annotation' :: Annotated ty => (ann -> ann') -> Lens (ty ann) (ty ann') ann ann'

-- | This is just shorthand for <tt><a>annotation'</a> id</tt>.
annotation :: (Annotated ty) => Lens' (ty ann) ann


-- | Utility types and functions for the rest of <tt>language-ninja</tt>.
--   
--   This module re-exports all of the modules under the
--   <a>Language.Ninja.Misc</a> namespace for convenience.
--   
--   It is recommended that you import it with the following style:
--   
--   <pre>
--   import qualified Language.Ninja.Misc as Misc
--   </pre>
module Language.Ninja.Misc

-- | This type represents a POSIX <tt>sh</tt> command line.
data Command

-- | Constructor for a <a>Command</a>.
makeCommand :: Text -> Command

-- | An isomorphism between a <a>Command</a> and its underlying
--   <a>Text</a>.
commandText :: Iso' Command Text

-- | This type represents a Unix path string.
data Path

-- | Construct a <a>Path</a> from some <a>Text</a>.
makePath :: Text -> Path

-- | An isomorphism between a <a>Path</a> and its underlying <a>IText</a>.
pathIText :: Iso' Path IText

-- | An isomorphism that gives access to a <a>Text</a>-typed view of a
--   <a>Path</a>, even though the underlying data has type <a>IText</a>.
--   
--   This is equivalent to <tt>pathIText . from Ninja.itext</tt>.
pathText :: Iso' Path Text

-- | An isomorphism that gives access to a <a>String</a>-typed view of a
--   <a>Path</a>.
pathString :: Iso' Path String

-- | An isomorphism between a <a>Path</a> and a <a>FilePath</a> from
--   <tt>system-filepath</tt>. This uses <a>decodeString</a> and
--   <a>encodeString</a>, so all the caveats on those functions apply here.
pathFP :: Iso' Path FilePath

-- | An interned (hash-consed) text type. This is a newtype over
--   <a>InternedText</a> from the <tt>intern</tt> package.
data IText

-- | Get the <a>Text</a> corresponding to the given <a>IText</a> value.
--   
--   <pre>
--   internText (uninternText x) = x
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; uninternText ("foobar" :: IText)
--   "foobar"
--   </pre>
uninternText :: IText -> Text

-- | Intern a <a>Text</a> value, resulting in an <a>IText</a> value.
--   
--   <pre>
--   uninternText (internText x) = x
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; internText ("foobar" :: Text)
--   "foobar"
--   </pre>
internText :: Text -> IText

-- | An <a>Iso'</a> between <a>Text</a> and <a>IText</a>.
--   
--   <pre>
--   ((fromString x) ^. itext) = T.pack x
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (("foobar" :: Text) ^. itext) :: IText
--   "foobar"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (("foobar" :: IText) ^. from itext) :: Text
--   "foobar"
--   </pre>
itext :: Iso' Text IText

-- | This type represents a positive number; i.e.: an integer greater than
--   zero.
data Positive

-- | Constructor for a <a>Positive</a>.
makePositive :: Int -> Maybe Positive

-- | A <a>Getter</a> for the <a>Int</a> underlying a <a>Positive</a>.
fromPositive :: Getter Positive Int

-- | If you have some type that represents an AST node, it is often useful
--   to add a polymorphic "annotation field" to it, which is used for
--   things like source positions.
--   
--   Specifically, suppose we have the following AST node type:
--   
--   <pre>
--   data Foo = Foo { _fooBar :: !Bar, _fooBaz :: !Baz } deriving (…)
--   </pre>
--   
--   Then an annotation field is added by the following process:
--   
--   <ol>
--   <li>Add an extra (final) type parameter <tt>ann</tt> to the type.</li>
--   <li>Add an extra field <tt>_fooAnn :: !ann</tt>.</li>
--   <li>Derive instances of <a>Functor</a>, <a>Foldable</a>, and
--   <a>Traversable</a>.</li>
--   <li>If the type is recursive, add a <a>Plated</a> instance. See
--   <a>Language.Ninja.AST.Expr</a> for a complete example of this.</li>
--   <li>Write an <a>Annotated</a> instance with the canonical lens given
--   by the <tt>_fooAnn</tt> field. There are plenty of examples around
--   this library.</li>
--   </ol>
--   
--   The end result then looks like:
--   
--   <pre>
--   data Foo ann
--     = Foo
--       { _fooAnn :: !ann
--       , _fooBar :: !Bar
--       , _fooBaz :: !Baz
--       }
--     deriving (…, Functor, Foldable, Traversable)
--   
--   instance Annotated Foo where
--     annotation' = …
--   </pre>
class (Functor ty) => Annotated (ty :: * -> *)

-- | Given a function that is used when <a>fmap</a>ing any subterms, return
--   a lens into the "annotation" field.
--   
--   When writing an instance, keep in mind that <tt><a>annotation'</a>
--   id</tt> should just be the typical definition for a lens into the
--   annotation field.
--   
--   <pre>
--   annotation' (f . g) == annotation' f . annotation' g
--   </pre>
annotation' :: Annotated ty => (ann -> ann') -> Lens (ty ann) (ty ann') ann ann'

-- | This is just shorthand for <tt><a>annotation'</a> id</tt>.
annotation :: (Annotated ty) => Lens' (ty ann) ann

-- | This datatype represents a value annotated with a source location.
data Located t

-- | Given <tt>path :: <a>Maybe</a> <a>Path</a></tt> and a <tt>text ::
--   <a>Text</a></tt>, do the following:
--   
--   <ul>
--   <li>Remove all <tt>'\r'</tt> characters from the <tt>text</tt>.</li>
--   <li>Split the <tt>text</tt> into chunks that are guaranteed not to
--   contain newlines or whitespace, and which are annotated with their
--   location.</li>
--   </ul>
tokenize :: Maybe Path -> Text -> [Located Text]

-- | Read the file at the given <a>Path</a> and then run <a>tokenize</a> on
--   the resulting <a>Text</a>.
tokenizeFile :: (MonadReadFile m) => Path -> m [Located Text]

-- | This function is equivalent to <tt>tokenize Nothing</tt>.
tokenizeText :: Text -> [Located Text]

-- | The position of this located value.
locatedPos :: Lens' (Located t) Position

-- | The value underlying this located value.
locatedVal :: Lens' (Located t) t

-- | A type representing a set of source spans.
data Spans

-- | Construct a <a>Spans</a> from a list of <a>Span</a>s.
makeSpans :: [Span] -> Spans

-- | A lens into the <tt><a>HashSet</a> <a>Span</a></tt> underlying a value
--   of type <a>Spans</a>.
spansSet :: Iso' Spans (HashSet Span)

-- | Represents a span of source code.
data Span

-- | Construct a <a>Span</a> from a given start position to a given end
--   position.
makeSpan :: Maybe Path -> Offset -> Offset -> Span

-- | A lens into the (nullable) path associated with a <a>Span</a>.
spanPath :: Lens' Span (Maybe Path)

-- | A lens giving the start and end <a>Offset</a>s associated with a
--   <a>Span</a>.
spanRange :: Lens' Span (Offset, Offset)

-- | A lens into the <a>Offset</a> associated with the start of a
--   <a>Span</a>.
spanStart :: Lens' Span Offset

-- | A lens into the <a>Offset</a> associated with the end of a
--   <a>Span</a>.
spanEnd :: Lens' Span Offset

-- | This datatype represents the position of a cursor in a text file.
data Position

-- | Construct a <a>Position</a> from a (nullable) path and a <tt>(line,
--   column)</tt> pair.
makePosition :: Maybe Path -> Offset -> Position

-- | The path of the file pointed to by this position, if any.
positionFile :: Lens' Position (Maybe Path)

-- | The offset in the file pointed to by this position.
positionOffset :: Lens' Position Offset

-- | The line number in the file pointed to by this position.
positionLine :: Lens' Position Line

-- | The column number in the line pointed to by this position.
positionCol :: Lens' Position Column

-- | If two <a>Position</a>s are comparable (i.e.: if they are in the same
--   file), this function will return an <a>Ordering</a> giving their
--   relative positions. Otherwise, it will of course return
--   <a>Nothing</a>.
comparePosition :: Position -> Position -> Maybe Ordering

-- | A line/column offset into a file.
type Offset = (Line, Column)

-- | Compare two <a>Offset</a>s in lexicographic order (i.e.: the
--   <a>Column</a> is ignored unless they are on the same <a>Line</a>).
compareOffset :: Offset -> Offset -> Ordering

-- | A lens into the <a>Line</a> associated with an <a>Offset</a>.
--   
--   For now, this is simply defined as <tt>offsetLine = <a>_1</a></tt>,
--   but if <a>Offset</a> is later refactored to be an abstract data type,
--   using this lens instead of <a>_1</a> will decrease the amount of code
--   that breaks.
offsetLine :: Lens' Offset Line

-- | A lens into the <a>Line</a> associated with an <a>Offset</a>.
--   
--   Read the description of <a>offsetLine</a> for an understanding of why
--   this exists and why you should use it instead of <a>_2</a>.
offsetColumn :: Lens' Offset Column

-- | A line number.
type Line = Int

-- | A column number.
type Column = Int


-- | Types relating to Ninja build targets, outputs, and dependencies.
module Language.Ninja.IR.Target

-- | This type represents a Ninja target name.
data Target

-- | Construct a <a>Target</a> from some <a>Text</a>.
makeTarget :: Text -> Target

-- | An isomorphism between a <a>Target</a> and its underlying
--   <tt>IText</tt>.
targetIText :: Iso' Target IText

-- | An isomorphism that gives access to a <a>Text</a>-typed view of a
--   <a>Target</a>, even though the underlying data has type
--   <tt>IText</tt>.
--   
--   This is equivalent to <tt>targetIText . from itext</tt>.
targetText :: Iso' Target Text

-- | A Ninja build output.
--   
--   More information is available <a>here</a>.
data Output

-- | Construct an <a>Output</a>.
makeOutput :: Target -> Output

-- | A lens for the <a>Target</a> of an <a>Output</a>.
outputTarget :: Lens' Output Target

-- | A build dependency.
--   
--   More information is available <a>here</a>.
data Dependency

-- | Construct a <a>Dependency</a>.
makeDependency :: Target -> DependencyType -> Dependency

-- | A lens for the <a>Target</a> of a <a>Dependency</a>.
dependencyTarget :: Lens' Dependency Target

-- | A lens for the <a>DependencyType</a> of a <a>Dependency</a>.
dependencyType :: Lens' Dependency DependencyType

-- | The type of a <a>Dependency</a>: normal, implicit, or order-only.
data DependencyType

-- | A normal dependency. These are listed in the <tt>$in</tt> variable and
--   changes in the relevant target result in a rule execution.
NormalDependency :: DependencyType

-- | An order-only dependency. These are listed in the <tt>$in</tt>
--   variable, but are only rebuilt if there is at least one non-order-only
--   dependency that is out of date.
--   
--   FIXME: double check this interpretation of the Ninja manual
OrderOnlyDependency :: DependencyType

-- | A prism for the <a>NormalDependency</a> constructor.
_NormalDependency :: Prism' DependencyType ()

-- | A prism for the <a>OrderOnlyDependency</a> constructor.
_OrderOnlyDependency :: Prism' DependencyType ()
instance GHC.Generics.Generic Language.Ninja.IR.Target.Dependency
instance GHC.Read.Read Language.Ninja.IR.Target.Dependency
instance GHC.Show.Show Language.Ninja.IR.Target.Dependency
instance GHC.Classes.Ord Language.Ninja.IR.Target.Dependency
instance GHC.Classes.Eq Language.Ninja.IR.Target.Dependency
instance GHC.Generics.Generic Language.Ninja.IR.Target.DependencyType
instance GHC.Read.Read Language.Ninja.IR.Target.DependencyType
instance GHC.Show.Show Language.Ninja.IR.Target.DependencyType
instance GHC.Classes.Ord Language.Ninja.IR.Target.DependencyType
instance GHC.Classes.Eq Language.Ninja.IR.Target.DependencyType
instance GHC.Generics.Generic Language.Ninja.IR.Target.Output
instance GHC.Read.Read Language.Ninja.IR.Target.Output
instance GHC.Show.Show Language.Ninja.IR.Target.Output
instance GHC.Classes.Ord Language.Ninja.IR.Target.Output
instance GHC.Classes.Eq Language.Ninja.IR.Target.Output
instance Data.Aeson.Types.FromJSON.FromJSONKey Language.Ninja.IR.Target.Target
instance Data.Aeson.Types.ToJSON.ToJSONKey Language.Ninja.IR.Target.Target
instance Data.Aeson.Types.FromJSON.FromJSON Language.Ninja.IR.Target.Target
instance Data.Aeson.Types.ToJSON.ToJSON Language.Ninja.IR.Target.Target
instance Control.DeepSeq.NFData Language.Ninja.IR.Target.Target
instance Data.Hashable.Class.Hashable Language.Ninja.IR.Target.Target
instance GHC.Generics.Generic Language.Ninja.IR.Target.Target
instance Data.String.IsString Language.Ninja.IR.Target.Target
instance GHC.Read.Read Language.Ninja.IR.Target.Target
instance GHC.Show.Show Language.Ninja.IR.Target.Target
instance GHC.Classes.Ord Language.Ninja.IR.Target.Target
instance GHC.Classes.Eq Language.Ninja.IR.Target.Target
instance (GHC.Base.Monad m, Test.SmallCheck.Series.Serial m Data.Text.Internal.Text) => Test.SmallCheck.Series.Serial m Language.Ninja.IR.Target.Target
instance (GHC.Base.Monad m, Test.SmallCheck.Series.CoSerial m Data.Text.Internal.Text) => Test.SmallCheck.Series.CoSerial m Language.Ninja.IR.Target.Target
instance Data.Aeson.Types.ToJSON.ToJSON Language.Ninja.IR.Target.Output
instance Data.Aeson.Types.FromJSON.FromJSON Language.Ninja.IR.Target.Output
instance Data.Hashable.Class.Hashable Language.Ninja.IR.Target.Output
instance Control.DeepSeq.NFData Language.Ninja.IR.Target.Output
instance (GHC.Base.Monad m, Test.SmallCheck.Series.Serial m Data.Text.Internal.Text) => Test.SmallCheck.Series.Serial m Language.Ninja.IR.Target.Output
instance (GHC.Base.Monad m, Test.SmallCheck.Series.CoSerial m Data.Text.Internal.Text) => Test.SmallCheck.Series.CoSerial m Language.Ninja.IR.Target.Output
instance Data.Aeson.Types.ToJSON.ToJSON Language.Ninja.IR.Target.Dependency
instance Data.Aeson.Types.FromJSON.FromJSON Language.Ninja.IR.Target.Dependency
instance Data.Hashable.Class.Hashable Language.Ninja.IR.Target.Dependency
instance Control.DeepSeq.NFData Language.Ninja.IR.Target.Dependency
instance (GHC.Base.Monad m, Test.SmallCheck.Series.Serial m Data.Text.Internal.Text) => Test.SmallCheck.Series.Serial m Language.Ninja.IR.Target.Dependency
instance (GHC.Base.Monad m, Test.SmallCheck.Series.CoSerial m Data.Text.Internal.Text) => Test.SmallCheck.Series.CoSerial m Language.Ninja.IR.Target.Dependency
instance Data.Aeson.Types.ToJSON.ToJSON Language.Ninja.IR.Target.DependencyType
instance Data.Aeson.Types.FromJSON.FromJSON Language.Ninja.IR.Target.DependencyType
instance Data.Hashable.Class.Hashable Language.Ninja.IR.Target.DependencyType
instance Control.DeepSeq.NFData Language.Ninja.IR.Target.DependencyType
instance GHC.Base.Monad m => Test.SmallCheck.Series.Serial m Language.Ninja.IR.Target.DependencyType
instance GHC.Base.Monad m => Test.SmallCheck.Series.CoSerial m Language.Ninja.IR.Target.DependencyType


-- | Types relating to Ninja <tt>pool</tt>s.
module Language.Ninja.IR.Pool

-- | A Ninja <tt>pool</tt> declaration, as documented <a>here</a>.
data Pool

-- | Construct a <a>Pool</a>, given its name and depth.
makePool :: PoolName -> PoolDepth -> Maybe Pool

-- | The default pool, i.e.: the one whose name is the empty string.
makePoolDefault :: Pool

-- | The <tt>console</tt> pool.
makePoolConsole :: Pool

-- | Create a pool with the given name and depth.
makePoolCustom :: Text -> Positive -> Pool

-- | A <tt>Getter</tt> that gives the name of a pool.
poolName :: Getter Pool PoolName

-- | A <tt>Getter</tt> that gives the depth of a pool.
poolDepth :: Getter Pool PoolDepth

-- | The name of a Ninja pool.
--   
--   More information is available <a>here</a>.
data PoolName

-- | Create a <a>PoolName</a> corresponding to the built-in default pool,
--   i.e.: the pool that is selected if the <tt>pool</tt> attribute is set
--   to the empty string.
makePoolNameDefault :: PoolName

-- | Create a <a>PoolName</a> corresponding to the built-in
--   <tt>console</tt> pool.
makePoolNameConsole :: PoolName

-- | Create a <a>PoolName</a> corresponding to a custom pool. Note: this
--   can fail at runtime if given the empty string or <tt>"console"</tt>,
--   so you should consider <a>parsePoolName</a> as a safer alternative.
makePoolNameCustom :: Text -> PoolName

-- | A one-way prism corresponding to the <tt>poolNameDefault</tt>
--   constructor.
_PoolNameDefault :: Getter PoolName (Maybe ())

-- | A one-way prism corresponding to the <tt>poolNameConsole</tt>
--   constructor.
_PoolNameConsole :: Getter PoolName (Maybe ())

-- | A one-way prism corresponding to the <tt>poolNameConsole</tt>
--   constructor.
_PoolNameCustom :: Getter PoolName (Maybe Text)

-- | An isomorphism between a <a>PoolName</a> and the corresponding
--   <a>Text</a>. Equivalent to <tt><a>iso</a> <a>printPoolName</a>
--   <a>parsePoolName</a></tt>.
poolNameText :: Iso' PoolName Text

-- | Convert a <a>PoolName</a> to the string that, if the <tt>pool</tt>
--   attribute is set to it, will cause the given <a>PoolName</a> to be
--   parsed.
--   
--   <pre>
--   &gt;&gt;&gt; printPoolName poolNameDefault
--   ""
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; printPoolName poolNameConsole
--   "console"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; printPoolName (poolNameCustom "foobar")
--   "foobar"
--   </pre>
printPoolName :: PoolName -> Text

-- | Inverse of <a>printPoolName</a>.
--   
--   <pre>
--   &gt;&gt;&gt; parsePoolName ""
--   PoolNameDefault
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parsePoolName "console"
--   PoolNameConsole
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parsePoolName "foobar"
--   PoolNameCustom "foobar"
--   </pre>
parsePoolName :: Text -> PoolName

-- | The depth of a Ninja pool.
--   
--   More information is available <a>here</a>.
data PoolDepth

-- | Construct a finite <a>PoolDepth</a> from an integer, which should be a
--   number greater than or equal to 1.
makePoolDepth :: Positive -> PoolDepth

-- | Construct an infinite <a>PoolDepth</a>. This constructor is needed for
--   the default pool (<tt>pool = ""</tt>), which has an infinite depth.
makePoolInfinite :: PoolDepth

-- | An isomorphism between a <a>PoolDepth</a> and a <tt><a>Maybe</a>
--   <a>Positive</a></tt>; the <a>Nothing</a> case maps to
--   <a>makePoolInfinite</a> and the <a>Just</a> case maps to
--   <a>makePoolDepth</a>.
poolDepthPositive :: Iso' PoolDepth (Maybe Positive)
instance GHC.Generics.Generic Language.Ninja.IR.Pool.Pool
instance GHC.Read.Read Language.Ninja.IR.Pool.Pool
instance GHC.Show.Show Language.Ninja.IR.Pool.Pool
instance GHC.Classes.Ord Language.Ninja.IR.Pool.Pool
instance GHC.Classes.Eq Language.Ninja.IR.Pool.Pool
instance GHC.Generics.Generic Language.Ninja.IR.Pool.PoolDepth
instance GHC.Read.Read Language.Ninja.IR.Pool.PoolDepth
instance GHC.Show.Show Language.Ninja.IR.Pool.PoolDepth
instance GHC.Classes.Ord Language.Ninja.IR.Pool.PoolDepth
instance GHC.Classes.Eq Language.Ninja.IR.Pool.PoolDepth
instance GHC.Generics.Generic Language.Ninja.IR.Pool.PoolName
instance GHC.Read.Read Language.Ninja.IR.Pool.PoolName
instance GHC.Show.Show Language.Ninja.IR.Pool.PoolName
instance GHC.Classes.Ord Language.Ninja.IR.Pool.PoolName
instance GHC.Classes.Eq Language.Ninja.IR.Pool.PoolName
instance Data.Aeson.Types.ToJSON.ToJSON Language.Ninja.IR.Pool.Pool
instance Data.Aeson.Types.FromJSON.FromJSON Language.Ninja.IR.Pool.Pool
instance (GHC.Base.Monad m, Test.SmallCheck.Series.Serial m Data.Text.Internal.Text) => Test.SmallCheck.Series.Serial m Language.Ninja.IR.Pool.Pool
instance (GHC.Base.Monad m, Test.SmallCheck.Series.CoSerial m Data.Text.Internal.Text) => Test.SmallCheck.Series.CoSerial m Language.Ninja.IR.Pool.Pool
instance Data.Hashable.Class.Hashable Language.Ninja.IR.Pool.Pool
instance Control.DeepSeq.NFData Language.Ninja.IR.Pool.Pool
instance Data.String.IsString Language.Ninja.IR.Pool.PoolName
instance Data.Aeson.Types.ToJSON.ToJSON Language.Ninja.IR.Pool.PoolName
instance Data.Aeson.Types.FromJSON.FromJSON Language.Ninja.IR.Pool.PoolName
instance Data.Aeson.Types.ToJSON.ToJSONKey Language.Ninja.IR.Pool.PoolName
instance Data.Aeson.Types.FromJSON.FromJSONKey Language.Ninja.IR.Pool.PoolName
instance (GHC.Base.Monad m, Test.SmallCheck.Series.Serial m Data.Text.Internal.Text) => Test.SmallCheck.Series.Serial m Language.Ninja.IR.Pool.PoolName
instance (GHC.Base.Monad m, Test.SmallCheck.Series.CoSerial m Data.Text.Internal.Text) => Test.SmallCheck.Series.CoSerial m Language.Ninja.IR.Pool.PoolName
instance Data.Hashable.Class.Hashable Language.Ninja.IR.Pool.PoolName
instance Control.DeepSeq.NFData Language.Ninja.IR.Pool.PoolName
instance Data.Aeson.Types.ToJSON.ToJSON Language.Ninja.IR.Pool.PoolDepth
instance Data.Aeson.Types.FromJSON.FromJSON Language.Ninja.IR.Pool.PoolDepth
instance GHC.Base.Monad m => Test.SmallCheck.Series.Serial m Language.Ninja.IR.Pool.PoolDepth
instance GHC.Base.Monad m => Test.SmallCheck.Series.CoSerial m Language.Ninja.IR.Pool.PoolDepth
instance Data.Hashable.Class.Hashable Language.Ninja.IR.Pool.PoolDepth
instance Control.DeepSeq.NFData Language.Ninja.IR.Pool.PoolDepth


-- | A datatype for Ninja <tt>rule</tt> declarations.
module Language.Ninja.IR.Rule

-- | A Ninja <tt>rule</tt> declaration, as documented <a>here</a>.
data Rule

-- | Construct an <a>Rule</a> with the given name and command, with default
--   values for all other attributes (e.g.: <a>False</a>, <a>Nothing</a>,
--   <tt>poolDefault</tt>).
makeRule :: Text -> Command -> Rule

-- | The name of the rule.
ruleName :: Lens' Rule Text

-- | The command that this rule will run.
ruleCommand :: Lens' Rule Command

-- | A short description of the command, used to pretty-print the command
--   as it's running. The <tt>ninja -v</tt> flag controls whether to print
--   the full command or its description; if a command fails, the full
--   command line will always be printed before the command's output.
ruleDescription :: Lens' Rule (Maybe Text)

-- | The process pool in which this rule will be executed.
rulePool :: Lens' Rule PoolName

-- | If set, this should be a path to an optional Makefile that contains
--   extra implicit dependencies. This is used to support C/C++ header
--   dependencies. For more information, read the Ninja documentation
--   <a>here</a>.
ruleDepfile :: Lens' Rule (Maybe Path)

-- | If set, enables special dependency processing used in C/C++ header
--   dependencies. For more information, read the Ninja documentation
--   <a>here</a>.
ruleSpecialDeps :: Lens' Rule (Maybe SpecialDeps)

-- | If this is true, specifies that this rule is used to re-invoke the
--   generator program. Files built using generator rules are treated
--   specially in two ways: firstly, they will not be rebuilt if the
--   command line changes; and secondly, they are not cleaned by default.
ruleGenerator :: Lens' Rule Bool

-- | If true, causes Ninja to re-stat the command's outputs after execution
--   of the command. Each output whose modification time the command did
--   not change will be treated as though it had never needed to be built.
--   This may cause the output's reverse dependencies to be removed from
--   the list of pending build actions.
ruleRestat :: Lens' Rule Bool

-- | If present, Ninja will use a response file for the given command, i.e.
--   write the selected string to the given file before calling the command
--   and delete the file after the command is done.
--   
--   This is particularly useful on Windows OS, where the maximal length of
--   a command line is limited and response files must be used instead.
ruleResponseFile :: Lens' Rule (Maybe ResponseFile)

-- | Special dependency information, as described <a>here</a>.
data SpecialDeps

-- | Construct a <a>SpecialDeps</a> corresponding to the case in which
--   <tt>deps = gcc</tt> is set in a Ninja build rule.
makeSpecialDepsGCC :: SpecialDeps

-- | Construct a <a>SpecialDeps</a> corresponding to the case in which
--   <tt>deps = msvc</tt> is set and <tt>msvc_deps_prefix = …</tt>.
--   
--   The <tt>msvc_deps_prefix</tt> field defines the string which should be
--   stripped from <tt>msvc</tt>'s <tt>/showIncludes</tt> output. It is
--   only needed if the version of Visual Studio being used is not English.
--   The value of <tt>msvc_deps_prefix</tt> is <tt>"Note: including file:
--   "</tt> by default.
makeSpecialDepsMSVC :: Text -> SpecialDeps

-- | A prism for the <tt>deps = gcc</tt> case.
_SpecialDepsGCC :: Prism' SpecialDeps ()

-- | A prism for the <tt>deps = msvc</tt> / <tt>msvc_deps_prefix = …</tt>
--   case.
_SpecialDepsMSVC :: Prism' SpecialDeps Text

-- | A response file to use during rule execution, as documented
--   <a>here</a>.
data ResponseFile

-- | Construct a <a>ResponseFile</a> with the given <a>Path</a> and content
--   <a>Text</a>.
makeResponseFile :: Path -> Text -> ResponseFile

-- | A lens for the <tt>rspfile</tt> field.
responseFilePath :: Lens' ResponseFile Path

-- | A lens for the <tt>rspfile_content</tt> field.
responseFileContent :: Lens' ResponseFile Text
instance GHC.Generics.Generic Language.Ninja.IR.Rule.Rule
instance GHC.Show.Show Language.Ninja.IR.Rule.Rule
instance GHC.Classes.Ord Language.Ninja.IR.Rule.Rule
instance GHC.Classes.Eq Language.Ninja.IR.Rule.Rule
instance GHC.Generics.Generic Language.Ninja.IR.Rule.ResponseFile
instance GHC.Show.Show Language.Ninja.IR.Rule.ResponseFile
instance GHC.Classes.Ord Language.Ninja.IR.Rule.ResponseFile
instance GHC.Classes.Eq Language.Ninja.IR.Rule.ResponseFile
instance GHC.Generics.Generic Language.Ninja.IR.Rule.SpecialDeps
instance GHC.Read.Read Language.Ninja.IR.Rule.SpecialDeps
instance GHC.Show.Show Language.Ninja.IR.Rule.SpecialDeps
instance GHC.Classes.Ord Language.Ninja.IR.Rule.SpecialDeps
instance GHC.Classes.Eq Language.Ninja.IR.Rule.SpecialDeps
instance Data.Aeson.Types.ToJSON.ToJSON Language.Ninja.IR.Rule.Rule
instance Data.Aeson.Types.FromJSON.FromJSON Language.Ninja.IR.Rule.Rule
instance Data.Hashable.Class.Hashable Language.Ninja.IR.Rule.Rule
instance Control.DeepSeq.NFData Language.Ninja.IR.Rule.Rule
instance (GHC.Base.Monad m, Test.SmallCheck.Series.Serial m Data.Text.Internal.Text) => Test.SmallCheck.Series.Serial m Language.Ninja.IR.Rule.Rule
instance (GHC.Base.Monad m, Test.SmallCheck.Series.CoSerial m Data.Text.Internal.Text) => Test.SmallCheck.Series.CoSerial m Language.Ninja.IR.Rule.Rule
instance Data.Aeson.Types.ToJSON.ToJSON Language.Ninja.IR.Rule.SpecialDeps
instance Data.Aeson.Types.FromJSON.FromJSON Language.Ninja.IR.Rule.SpecialDeps
instance Data.Hashable.Class.Hashable Language.Ninja.IR.Rule.SpecialDeps
instance Control.DeepSeq.NFData Language.Ninja.IR.Rule.SpecialDeps
instance (GHC.Base.Monad m, Test.SmallCheck.Series.Serial m Data.Text.Internal.Text) => Test.SmallCheck.Series.Serial m Language.Ninja.IR.Rule.SpecialDeps
instance (GHC.Base.Monad m, Test.SmallCheck.Series.CoSerial m Data.Text.Internal.Text) => Test.SmallCheck.Series.CoSerial m Language.Ninja.IR.Rule.SpecialDeps
instance Data.Aeson.Types.ToJSON.ToJSON Language.Ninja.IR.Rule.ResponseFile
instance Data.Aeson.Types.FromJSON.FromJSON Language.Ninja.IR.Rule.ResponseFile
instance Data.Hashable.Class.Hashable Language.Ninja.IR.Rule.ResponseFile
instance Control.DeepSeq.NFData Language.Ninja.IR.Rule.ResponseFile
instance (GHC.Base.Monad m, Test.SmallCheck.Series.Serial m Data.Text.Internal.Text) => Test.SmallCheck.Series.Serial m Language.Ninja.IR.Rule.ResponseFile
instance (GHC.Base.Monad m, Test.SmallCheck.Series.CoSerial m Data.Text.Internal.Text) => Test.SmallCheck.Series.CoSerial m Language.Ninja.IR.Rule.ResponseFile


-- | A datatype for Ninja top-level variables and other metadata.
module Language.Ninja.IR.Meta

-- | Ninja top-level metadata, as documented <a>here</a>.
data Meta

-- | Construct a default <a>Meta</a> value.
makeMeta :: Meta

-- | Corresponds to the <tt>ninja_required_version</tt> top-level variable.
metaReqVersion :: Lens' Meta (Maybe Version)

-- | Corresponds to the <tt>builddir</tt> top-level variable.
metaBuildDir :: Lens' Meta (Maybe Path)
instance GHC.Generics.Generic Language.Ninja.IR.Meta.Meta
instance GHC.Show.Show Language.Ninja.IR.Meta.Meta
instance GHC.Classes.Ord Language.Ninja.IR.Meta.Meta
instance GHC.Classes.Eq Language.Ninja.IR.Meta.Meta
instance Data.Aeson.Types.ToJSON.ToJSON Language.Ninja.IR.Meta.Meta
instance Data.Aeson.Types.FromJSON.FromJSON Language.Ninja.IR.Meta.Meta
instance Data.Hashable.Class.Hashable Language.Ninja.IR.Meta.Meta
instance Control.DeepSeq.NFData Language.Ninja.IR.Meta.Meta
instance (GHC.Base.Monad m, Test.SmallCheck.Series.Serial m Data.Versions.Version, Test.SmallCheck.Series.Serial m Data.Text.Internal.Text) => Test.SmallCheck.Series.Serial m Language.Ninja.IR.Meta.Meta
instance (GHC.Base.Monad m, Test.SmallCheck.Series.CoSerial m Data.Versions.Version, Test.SmallCheck.Series.CoSerial m Data.Text.Internal.Text) => Test.SmallCheck.Series.CoSerial m Language.Ninja.IR.Meta.Meta


-- | A datatype for Ninja <tt>build</tt> declarations.
module Language.Ninja.IR.Build

-- | A Ninja <tt>build</tt> declaration, as documented <a>here</a>.
data Build

-- | Construct a default <a>Build</a> from the given <a>Rule</a>
makeBuild :: Rule -> Build

-- | The rule to execute when building any of the outputs.
buildRule :: Lens' Build Rule

-- | The outputs that are built as a result of rule execution.
buildOuts :: Lens' Build (HashSet Output)

-- | The dependencies that must be satisfied before this can be built.
buildDeps :: Lens' Build (HashSet Dependency)

-- | The set of constraints required for a given constraint to be
--   automatically computed for a <a>Build</a>.
type BuildConstraint (c :: * -> Constraint) = (c Text, c (HashSet Output), c (HashSet Dependency))
instance GHC.Generics.Generic Language.Ninja.IR.Build.Build
instance GHC.Show.Show Language.Ninja.IR.Build.Build
instance GHC.Classes.Eq Language.Ninja.IR.Build.Build
instance Data.Aeson.Types.ToJSON.ToJSON Language.Ninja.IR.Build.Build
instance Data.Aeson.Types.FromJSON.FromJSON Language.Ninja.IR.Build.Build
instance Data.Hashable.Class.Hashable Language.Ninja.IR.Build.Build
instance Control.DeepSeq.NFData Language.Ninja.IR.Build.Build
instance (GHC.Base.Monad m, Language.Ninja.IR.Build.BuildConstraint (Test.SmallCheck.Series.Serial m)) => Test.SmallCheck.Series.Serial m Language.Ninja.IR.Build.Build
instance (GHC.Base.Monad m, Language.Ninja.IR.Build.BuildConstraint (Test.SmallCheck.Series.CoSerial m)) => Test.SmallCheck.Series.CoSerial m Language.Ninja.IR.Build.Build


-- | A datatype representing the intermediate representation of a Ninja
--   file after compilation.
module Language.Ninja.IR.Ninja

-- | A parsed and normalized Ninja file.
data Ninja

-- | Construct a default <a>Ninja</a> value.
makeNinja :: Ninja

-- | Metadata, which includes top-level variables like <tt>builddir</tt>.
ninjaMeta :: Lens' Ninja Meta

-- | Compiled <tt>build</tt> declarations.
ninjaBuilds :: Lens' Ninja (HashSet Build)

-- | Phony targets, as documented <a>here</a>.
ninjaPhonys :: Lens' Ninja (HashMap Target (HashSet Target))

-- | The set of default targets, as documented <a>here</a>.
ninjaDefaults :: Lens' Ninja (HashSet Target)

-- | The set of pools for this Ninja file.
ninjaPools :: Lens' Ninja (HashSet Pool)

-- | The set of constraints required for a given constraint to be
--   automatically computed for a <a>Ninja</a>.
type NinjaConstraint (c :: * -> Constraint) = (c Text, c Version, c (HashMap Target (HashSet Target)), c (HashSet Build), c (HashSet Target), c (HashSet Pool))
instance GHC.Generics.Generic Language.Ninja.IR.Ninja.Ninja
instance GHC.Show.Show Language.Ninja.IR.Ninja.Ninja
instance GHC.Classes.Eq Language.Ninja.IR.Ninja.Ninja
instance Data.Aeson.Types.ToJSON.ToJSON Language.Ninja.IR.Ninja.Ninja
instance Data.Aeson.Types.FromJSON.FromJSON Language.Ninja.IR.Ninja.Ninja
instance Data.Hashable.Class.Hashable Language.Ninja.IR.Ninja.Ninja
instance Control.DeepSeq.NFData Language.Ninja.IR.Ninja.Ninja
instance (GHC.Base.Monad m, Language.Ninja.IR.Ninja.NinjaConstraint (Test.SmallCheck.Series.Serial m)) => Test.SmallCheck.Series.Serial m Language.Ninja.IR.Ninja.Ninja
instance (GHC.Base.Monad m, Language.Ninja.IR.Ninja.NinjaConstraint (Test.SmallCheck.Series.CoSerial m)) => Test.SmallCheck.Series.CoSerial m Language.Ninja.IR.Ninja.Ninja


-- | The Ninja build language intermediate representation after
--   compilation.
--   
--   This module re-exports all of the modules under the
--   <a>Language.Ninja.IR</a> namespace for convenience.
--   
--   It is recommended that you import it with the following style:
--   
--   <pre>
--   import qualified Language.Ninja.IR as IR
--   </pre>
module Language.Ninja.IR

-- | A parsed and normalized Ninja file.
data Ninja

-- | Construct a default <a>Ninja</a> value.
makeNinja :: Ninja

-- | Metadata, which includes top-level variables like <tt>builddir</tt>.
ninjaMeta :: Lens' Ninja Meta

-- | Compiled <tt>build</tt> declarations.
ninjaBuilds :: Lens' Ninja (HashSet Build)

-- | Phony targets, as documented <a>here</a>.
ninjaPhonys :: Lens' Ninja (HashMap Target (HashSet Target))

-- | The set of default targets, as documented <a>here</a>.
ninjaDefaults :: Lens' Ninja (HashSet Target)

-- | The set of pools for this Ninja file.
ninjaPools :: Lens' Ninja (HashSet Pool)

-- | Ninja top-level metadata, as documented <a>here</a>.
data Meta

-- | Construct a default <a>Meta</a> value.
makeMeta :: Meta

-- | Corresponds to the <tt>ninja_required_version</tt> top-level variable.
metaReqVersion :: Lens' Meta (Maybe Version)

-- | Corresponds to the <tt>builddir</tt> top-level variable.
metaBuildDir :: Lens' Meta (Maybe Path)

-- | A Ninja <tt>build</tt> declaration, as documented <a>here</a>.
data Build

-- | Construct a default <a>Build</a> from the given <a>Rule</a>
makeBuild :: Rule -> Build

-- | The rule to execute when building any of the outputs.
buildRule :: Lens' Build Rule

-- | The outputs that are built as a result of rule execution.
buildOuts :: Lens' Build (HashSet Output)

-- | The dependencies that must be satisfied before this can be built.
buildDeps :: Lens' Build (HashSet Dependency)

-- | A Ninja <tt>rule</tt> declaration, as documented <a>here</a>.
data Rule

-- | Construct an <a>Rule</a> with the given name and command, with default
--   values for all other attributes (e.g.: <a>False</a>, <a>Nothing</a>,
--   <tt>poolDefault</tt>).
makeRule :: Text -> Command -> Rule

-- | The name of the rule.
ruleName :: Lens' Rule Text

-- | The command that this rule will run.
ruleCommand :: Lens' Rule Command

-- | A short description of the command, used to pretty-print the command
--   as it's running. The <tt>ninja -v</tt> flag controls whether to print
--   the full command or its description; if a command fails, the full
--   command line will always be printed before the command's output.
ruleDescription :: Lens' Rule (Maybe Text)

-- | The process pool in which this rule will be executed.
rulePool :: Lens' Rule PoolName

-- | If set, this should be a path to an optional Makefile that contains
--   extra implicit dependencies. This is used to support C/C++ header
--   dependencies. For more information, read the Ninja documentation
--   <a>here</a>.
ruleDepfile :: Lens' Rule (Maybe Path)

-- | If set, enables special dependency processing used in C/C++ header
--   dependencies. For more information, read the Ninja documentation
--   <a>here</a>.
ruleSpecialDeps :: Lens' Rule (Maybe SpecialDeps)

-- | If this is true, specifies that this rule is used to re-invoke the
--   generator program. Files built using generator rules are treated
--   specially in two ways: firstly, they will not be rebuilt if the
--   command line changes; and secondly, they are not cleaned by default.
ruleGenerator :: Lens' Rule Bool

-- | If true, causes Ninja to re-stat the command's outputs after execution
--   of the command. Each output whose modification time the command did
--   not change will be treated as though it had never needed to be built.
--   This may cause the output's reverse dependencies to be removed from
--   the list of pending build actions.
ruleRestat :: Lens' Rule Bool

-- | If present, Ninja will use a response file for the given command, i.e.
--   write the selected string to the given file before calling the command
--   and delete the file after the command is done.
--   
--   This is particularly useful on Windows OS, where the maximal length of
--   a command line is limited and response files must be used instead.
ruleResponseFile :: Lens' Rule (Maybe ResponseFile)

-- | Special dependency information, as described <a>here</a>.
data SpecialDeps

-- | Construct a <a>SpecialDeps</a> corresponding to the case in which
--   <tt>deps = gcc</tt> is set in a Ninja build rule.
makeSpecialDepsGCC :: SpecialDeps

-- | Construct a <a>SpecialDeps</a> corresponding to the case in which
--   <tt>deps = msvc</tt> is set and <tt>msvc_deps_prefix = …</tt>.
--   
--   The <tt>msvc_deps_prefix</tt> field defines the string which should be
--   stripped from <tt>msvc</tt>'s <tt>/showIncludes</tt> output. It is
--   only needed if the version of Visual Studio being used is not English.
--   The value of <tt>msvc_deps_prefix</tt> is <tt>"Note: including file:
--   "</tt> by default.
makeSpecialDepsMSVC :: Text -> SpecialDeps

-- | A prism for the <tt>deps = gcc</tt> case.
_SpecialDepsGCC :: Prism' SpecialDeps ()

-- | A prism for the <tt>deps = msvc</tt> / <tt>msvc_deps_prefix = …</tt>
--   case.
_SpecialDepsMSVC :: Prism' SpecialDeps Text

-- | A response file to use during rule execution, as documented
--   <a>here</a>.
data ResponseFile

-- | Construct a <a>ResponseFile</a> with the given <a>Path</a> and content
--   <a>Text</a>.
makeResponseFile :: Path -> Text -> ResponseFile

-- | A lens for the <tt>rspfile</tt> field.
responseFilePath :: Lens' ResponseFile Path

-- | A lens for the <tt>rspfile_content</tt> field.
responseFileContent :: Lens' ResponseFile Text

-- | This type represents a Ninja target name.
data Target

-- | Construct a <a>Target</a> from some <a>Text</a>.
makeTarget :: Text -> Target

-- | An isomorphism between a <a>Target</a> and its underlying
--   <tt>IText</tt>.
targetIText :: Iso' Target IText

-- | An isomorphism that gives access to a <a>Text</a>-typed view of a
--   <a>Target</a>, even though the underlying data has type
--   <tt>IText</tt>.
--   
--   This is equivalent to <tt>targetIText . from itext</tt>.
targetText :: Iso' Target Text

-- | A Ninja build output.
--   
--   More information is available <a>here</a>.
data Output

-- | Construct an <a>Output</a>.
makeOutput :: Target -> Output

-- | A lens for the <a>Target</a> of an <a>Output</a>.
outputTarget :: Lens' Output Target

-- | A build dependency.
--   
--   More information is available <a>here</a>.
data Dependency

-- | Construct a <a>Dependency</a>.
makeDependency :: Target -> DependencyType -> Dependency

-- | A lens for the <a>Target</a> of a <a>Dependency</a>.
dependencyTarget :: Lens' Dependency Target

-- | A lens for the <a>DependencyType</a> of a <a>Dependency</a>.
dependencyType :: Lens' Dependency DependencyType

-- | The type of a <a>Dependency</a>: normal, implicit, or order-only.
data DependencyType

-- | A normal dependency. These are listed in the <tt>$in</tt> variable and
--   changes in the relevant target result in a rule execution.
NormalDependency :: DependencyType

-- | An order-only dependency. These are listed in the <tt>$in</tt>
--   variable, but are only rebuilt if there is at least one non-order-only
--   dependency that is out of date.
--   
--   FIXME: double check this interpretation of the Ninja manual
OrderOnlyDependency :: DependencyType

-- | A prism for the <a>NormalDependency</a> constructor.
_NormalDependency :: Prism' DependencyType ()

-- | A prism for the <a>OrderOnlyDependency</a> constructor.
_OrderOnlyDependency :: Prism' DependencyType ()

-- | A Ninja <tt>pool</tt> declaration, as documented <a>here</a>.
data Pool

-- | Construct a <a>Pool</a>, given its name and depth.
makePool :: PoolName -> PoolDepth -> Maybe Pool

-- | The default pool, i.e.: the one whose name is the empty string.
makePoolDefault :: Pool

-- | The <tt>console</tt> pool.
makePoolConsole :: Pool

-- | Create a pool with the given name and depth.
makePoolCustom :: Text -> Positive -> Pool

-- | A <tt>Getter</tt> that gives the name of a pool.
poolName :: Getter Pool PoolName

-- | A <tt>Getter</tt> that gives the depth of a pool.
poolDepth :: Getter Pool PoolDepth

-- | The name of a Ninja pool.
--   
--   More information is available <a>here</a>.
data PoolName

-- | Create a <a>PoolName</a> corresponding to the built-in default pool,
--   i.e.: the pool that is selected if the <tt>pool</tt> attribute is set
--   to the empty string.
makePoolNameDefault :: PoolName

-- | Create a <a>PoolName</a> corresponding to the built-in
--   <tt>console</tt> pool.
makePoolNameConsole :: PoolName

-- | Create a <a>PoolName</a> corresponding to a custom pool. Note: this
--   can fail at runtime if given the empty string or <tt>"console"</tt>,
--   so you should consider <a>parsePoolName</a> as a safer alternative.
makePoolNameCustom :: Text -> PoolName

-- | A one-way prism corresponding to the <tt>poolNameDefault</tt>
--   constructor.
_PoolNameDefault :: Getter PoolName (Maybe ())

-- | A one-way prism corresponding to the <tt>poolNameConsole</tt>
--   constructor.
_PoolNameConsole :: Getter PoolName (Maybe ())

-- | A one-way prism corresponding to the <tt>poolNameConsole</tt>
--   constructor.
_PoolNameCustom :: Getter PoolName (Maybe Text)

-- | An isomorphism between a <a>PoolName</a> and the corresponding
--   <a>Text</a>. Equivalent to <tt><a>iso</a> <a>printPoolName</a>
--   <a>parsePoolName</a></tt>.
poolNameText :: Iso' PoolName Text

-- | Convert a <a>PoolName</a> to the string that, if the <tt>pool</tt>
--   attribute is set to it, will cause the given <a>PoolName</a> to be
--   parsed.
--   
--   <pre>
--   &gt;&gt;&gt; printPoolName poolNameDefault
--   ""
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; printPoolName poolNameConsole
--   "console"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; printPoolName (poolNameCustom "foobar")
--   "foobar"
--   </pre>
printPoolName :: PoolName -> Text

-- | Inverse of <a>printPoolName</a>.
--   
--   <pre>
--   &gt;&gt;&gt; parsePoolName ""
--   PoolNameDefault
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parsePoolName "console"
--   PoolNameConsole
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parsePoolName "foobar"
--   PoolNameCustom "foobar"
--   </pre>
parsePoolName :: Text -> PoolName

-- | The depth of a Ninja pool.
--   
--   More information is available <a>here</a>.
data PoolDepth

-- | Construct a finite <a>PoolDepth</a> from an integer, which should be a
--   number greater than or equal to 1.
makePoolDepth :: Positive -> PoolDepth

-- | Construct an infinite <a>PoolDepth</a>. This constructor is needed for
--   the default pool (<tt>pool = ""</tt>), which has an infinite depth.
makePoolInfinite :: PoolDepth

-- | An isomorphism between a <a>PoolDepth</a> and a <tt><a>Maybe</a>
--   <a>Positive</a></tt>; the <a>Nothing</a> case maps to
--   <a>makePoolInfinite</a> and the <a>Just</a> case maps to
--   <a>makePoolDepth</a>.
poolDepthPositive :: Iso' PoolDepth (Maybe Positive)


-- | Errors thrown during Ninja parsing.
module Language.Ninja.Errors.Parser

-- | The type of errors encountered during parsing.
data ParseError

-- | Generic catch-all error constructor. Avoid using this.
GenericParseError :: !Text -> ParseError

-- | <pre>
--   Lexer failed at binding: <a>text</a>
--   </pre>
LexBindingFailure :: !Text -> ParseError

-- | <pre>
--   Expected a colon
--   </pre>
LexExpectedColon :: ParseError

-- | <pre>
--   Unexpected $ followed by unexpected stuff
--   </pre>
LexUnexpectedDollar :: ParseError

-- | Lexer expected a separator character but found something else
LexUnexpectedSeparator :: Char -> ParseError

-- | Any other lexer error.
LexParsecError :: !(ParseError Char Dec) -> ParseError

-- | <pre>
--   Could not parse depth field in pool, got: <a>text</a>
--   </pre>
ParseBadDepthField :: !Text -> ParseError

-- | <pre>
--   Unexpected binding defining <a>text</a>
--   </pre>
ParseUnexpectedBinding :: !Text -> ParseError

-- | Throw a <a>ParseError</a>.
throwParseError :: (MonadError ParseError m) => ParseError -> m a

-- | Throw a generic catch-all <a>ParseError</a>.
throwGenericParseError :: (MonadError ParseError m) => Text -> m a

-- | Throw a <a>LexBindingFailure</a> error.
throwLexBindingFailure :: (MonadError ParseError m) => Text -> m a

-- | Throw a <a>LexExpectedColon</a> error.
throwLexExpectedColon :: (MonadError ParseError m) => m a

-- | Throw a <tt>LexUnexpectedColon</tt> error.
throwLexUnexpectedDollar :: (MonadError ParseError m) => m a

-- | Throw a <a>LexUnexpectedSeparator</a> error.
throwLexUnexpectedSeparator :: (MonadError ParseError m) => Char -> m a

-- | Throw a <a>LexParsecError</a> error.
throwLexParsecError :: (MonadError ParseError m) => ParseError Char Dec -> m a

-- | Throw a <a>ParseBadDepthField</a> error.
throwParseBadDepthField :: (MonadError ParseError m) => Text -> m a

-- | Throw a <a>ParseUnexpectedBinding</a> error.
throwParseUnexpectedBinding :: (MonadError ParseError m) => Text -> m a
instance GHC.Generics.Generic Language.Ninja.Errors.Parser.ParseError
instance GHC.Show.Show Language.Ninja.Errors.Parser.ParseError
instance GHC.Classes.Eq Language.Ninja.Errors.Parser.ParseError
instance GHC.Exception.Exception Language.Ninja.Errors.Parser.ParseError


-- | Errors thrown during Ninja compilation.
module Language.Ninja.Errors.Compile

-- | The type of errors encountered during compilation.
data CompileError

-- | Generic catch-all error constructor. Avoid using this.
GenericCompileError :: !Text -> CompileError

-- | Errors encountered while compiling a <tt>Meta</tt>.
CompileMetaError :: !CompileMetaError -> CompileError

-- | Errors encountered while compiling a <tt>Build</tt>.
CompileBuildError :: !CompileBuildError -> CompileError

-- | Errors encountered while compiling a <tt>Rule</tt>.
CompileRuleError :: !CompileRuleError -> CompileError

-- | Errors encountered while compiling the phony <tt>HashMap</tt>.
CompilePhonyError :: !CompilePhonyError -> CompileError

-- | Errors encountered while compiling the default target
--   <tt>HashSet</tt>.
CompileDefaultError :: !CompileDefaultError -> CompileError

-- | Errors encountered while compiling a <tt>Pool</tt>.
CompilePoolError :: !CompilePoolError -> CompileError

-- | Throw a <a>CompileError</a>.
throwCompileError :: (MonadError CompileError m) => CompileError -> m a

-- | Throw a generic catch-all <a>CompileError</a>.
throwGenericCompileError :: (MonadError CompileError m) => Text -> m a

-- | The type of errors encountered while compiling Ninja metadata.
data CompileMetaError

-- | Generic catch-all error constructor. Avoid using this.
GenericCompileMetaError :: !Text -> CompileMetaError

-- | <pre>
--   Failed to parse <tt>ninja_required_version</tt>: …
--   </pre>
VersionParseFailure :: !ParsingError -> CompileMetaError

-- | Throw a <a>CompileMetaError</a>.
throwCompileMetaError :: (MonadError CompileError m) => CompileMetaError -> m a

-- | Throw a generic catch-all <a>CompileMetaError</a>.
throwGenericCompileMetaError :: (MonadError CompileError m) => Text -> m a

-- | Throw a <a>VersionParseFailure</a> error.
throwVersionParseFailure :: (MonadError CompileError m) => ParsingError -> m a

-- | The type of errors encountered while compiling a Ninja phony
--   <tt>build</tt>.
data CompilePhonyError

-- | Generic catch-all error constructor. Avoid using this.
GenericCompilePhonyError :: !Text -> CompilePhonyError

-- | Throw a <a>CompilePhonyError</a>.
throwCompilePhonyError :: (MonadError CompileError m) => CompilePhonyError -> m a

-- | Throw a generic catch-all <a>CompilePhonyError</a>.
throwGenericCompilePhonyError :: (MonadError CompileError m) => Text -> m a

-- | The type of errors encountered while compiling a Ninja
--   <tt>default</tt> statement.
data CompileDefaultError

-- | Generic catch-all error constructor. Avoid using this.
GenericCompileDefaultError :: !Text -> CompileDefaultError

-- | Throw a <a>CompileDefaultError</a>.
throwCompileDefaultError :: (MonadError CompileError m) => CompileDefaultError -> m a

-- | Throw a generic catch-all <a>CompileDefaultError</a>.
throwGenericCompileDefaultError :: (MonadError CompileError m) => Text -> m a

-- | The type of errors encountered while compiling a Ninja <tt>build</tt>
--   statement.
data CompileBuildError

-- | Generic catch-all error constructor. Avoid using this.
GenericCompileBuildError :: !Text -> CompileBuildError

-- | <pre>
--   Rule not found: <a>text</a>
--   </pre>
BuildRuleNotFound :: !Text -> CompileBuildError

-- | Throw a <a>CompileBuildError</a>.
throwCompileBuildError :: (MonadError CompileError m) => CompileBuildError -> m a

-- | Throw a generic catch-all <a>CompileBuildError</a>.
throwGenericCompileBuildError :: (MonadError CompileError m) => Text -> m a

-- | Throw a <a>BuildRuleNotFound</a> error.
throwBuildRuleNotFound :: (MonadError CompileError m) => Text -> m a

-- | The type of errors encountered while compiling a Ninja <tt>rule</tt>
--   statement.
data CompileRuleError

-- | Generic catch-all error constructor. Avoid using this.
GenericCompileRuleError :: !Text -> CompileRuleError

-- | <pre>
--   Lookup failed on rule variable: <a>text</a>
--   </pre>
RuleLookupFailure :: !Text -> CompileRuleError

-- | <pre>
--   Unknown <tt>deps</tt> value: <a>text</a>
--   </pre>
UnknownDepsValue :: !Text -> CompileRuleError

-- | <pre>
--   Unexpected <tt>msvc_deps_prefix</tt> for `deps = "<a>text</a>"`
--   </pre>
UnexpectedMSVCPrefix :: !Text -> CompileRuleError

-- | Throw a <a>CompileRuleError</a>.
throwCompileRuleError :: (MonadError CompileError m) => CompileRuleError -> m a

-- | Throw a generic catch-all <a>CompileRuleError</a>.
throwGenericCompileRuleError :: (MonadError CompileError m) => Text -> m a

-- | Throw a <a>RuleLookupFailure</a> error.
throwRuleLookupFailure :: (MonadError CompileError m) => Text -> m a

-- | Throw an <tt>UnknownDeps</tt> error.
throwUnknownDeps :: (MonadError CompileError m) => Text -> m a

-- | Throw an <a>UnexpectedMSVCPrefix</a> error.
throwUnexpectedMSVCPrefix :: (MonadError CompileError m) => Text -> m a

-- | The type of errors encountered while compiling a Ninja <tt>pool</tt>
--   statement.
data CompilePoolError

-- | Generic catch-all error constructor. Avoid using this.
GenericCompilePoolError :: !Text -> CompilePoolError

-- | <pre>
--   Invalid pool depth for console: <a>int</a>
--   </pre>
InvalidPoolDepth :: !Int -> CompilePoolError

-- | <pre>
--   Pool name is an empty string
--   </pre>
EmptyPoolName :: CompilePoolError

-- | Throw a <a>CompilePoolError</a>.
throwCompilePoolError :: (MonadError CompileError m) => CompilePoolError -> m a

-- | Throw a generic catch-all <a>CompilePoolError</a>.
throwGenericCompilePoolError :: (MonadError CompileError m) => Text -> m a

-- | Throw an <a>InvalidPoolDepth</a> error.
throwInvalidPoolDepth :: (MonadError CompileError m) => Int -> m a

-- | Throw an <a>EmptyPoolName</a> error.
throwEmptyPoolName :: (MonadError CompileError m) => m a
instance GHC.Generics.Generic Language.Ninja.Errors.Compile.CompileError
instance GHC.Show.Show Language.Ninja.Errors.Compile.CompileError
instance GHC.Classes.Eq Language.Ninja.Errors.Compile.CompileError
instance GHC.Generics.Generic Language.Ninja.Errors.Compile.CompilePoolError
instance GHC.Show.Show Language.Ninja.Errors.Compile.CompilePoolError
instance GHC.Classes.Eq Language.Ninja.Errors.Compile.CompilePoolError
instance GHC.Generics.Generic Language.Ninja.Errors.Compile.CompileRuleError
instance GHC.Show.Show Language.Ninja.Errors.Compile.CompileRuleError
instance GHC.Classes.Eq Language.Ninja.Errors.Compile.CompileRuleError
instance GHC.Generics.Generic Language.Ninja.Errors.Compile.CompileBuildError
instance GHC.Show.Show Language.Ninja.Errors.Compile.CompileBuildError
instance GHC.Classes.Eq Language.Ninja.Errors.Compile.CompileBuildError
instance GHC.Generics.Generic Language.Ninja.Errors.Compile.CompileDefaultError
instance GHC.Show.Show Language.Ninja.Errors.Compile.CompileDefaultError
instance GHC.Classes.Eq Language.Ninja.Errors.Compile.CompileDefaultError
instance GHC.Generics.Generic Language.Ninja.Errors.Compile.CompilePhonyError
instance GHC.Show.Show Language.Ninja.Errors.Compile.CompilePhonyError
instance GHC.Classes.Eq Language.Ninja.Errors.Compile.CompilePhonyError
instance GHC.Generics.Generic Language.Ninja.Errors.Compile.CompileMetaError
instance GHC.Show.Show Language.Ninja.Errors.Compile.CompileMetaError
instance GHC.Classes.Eq Language.Ninja.Errors.Compile.CompileMetaError
instance GHC.Exception.Exception Language.Ninja.Errors.Compile.CompileError


-- | This module re-exports all of the modules under the
--   <a>Language.Ninja.Errors</a> namespace for convenience.
--   
--   It is recommended that you import it with the following style:
--   
--   <pre>
--   import qualified Language.Ninja.Errors as Errors
--   </pre>
module Language.Ninja.Errors

-- | This type subsumes any error that can be thrown during execution of a
--   function defined in <tt>language-ninja</tt>.
data NinjaError

-- | Generic catch-all error constructor. Avoid using this.
GenericNinjaError :: !Text -> NinjaError

-- | Errors encountered during parsing.
NinjaParseError :: !ParseError -> NinjaError

-- | Errors encountered during compilation.
NinjaCompileError :: !CompileError -> NinjaError

-- | Throw a <a>NinjaError</a>.
throwNinjaError :: (MonadError NinjaError m) => NinjaError -> m a

-- | Throw a generic catch-all <a>NinjaError</a>.
throwGenericNinjaError :: (MonadError NinjaError m) => Text -> m a

-- | Throw a <a>ParseError</a>.
throwNinjaParseError :: (MonadError NinjaError m) => ParseError -> m a

-- | Throw a <a>CompileError</a>.
throwNinjaCompileError :: (MonadError NinjaError m) => CompileError -> m a

-- | The type of errors encountered during compilation.
data CompileError

-- | Generic catch-all error constructor. Avoid using this.
GenericCompileError :: !Text -> CompileError

-- | Errors encountered while compiling a <tt>Meta</tt>.
CompileMetaError :: !CompileMetaError -> CompileError

-- | Errors encountered while compiling a <tt>Build</tt>.
CompileBuildError :: !CompileBuildError -> CompileError

-- | Errors encountered while compiling a <tt>Rule</tt>.
CompileRuleError :: !CompileRuleError -> CompileError

-- | Errors encountered while compiling the phony <tt>HashMap</tt>.
CompilePhonyError :: !CompilePhonyError -> CompileError

-- | Errors encountered while compiling the default target
--   <tt>HashSet</tt>.
CompileDefaultError :: !CompileDefaultError -> CompileError

-- | Errors encountered while compiling a <tt>Pool</tt>.
CompilePoolError :: !CompilePoolError -> CompileError

-- | Throw a <a>CompileError</a>.
throwCompileError :: (MonadError CompileError m) => CompileError -> m a

-- | Throw a generic catch-all <a>CompileError</a>.
throwGenericCompileError :: (MonadError CompileError m) => Text -> m a

-- | The type of errors encountered while compiling Ninja metadata.
data CompileMetaError

-- | Generic catch-all error constructor. Avoid using this.
GenericCompileMetaError :: !Text -> CompileMetaError

-- | <pre>
--   Failed to parse <tt>ninja_required_version</tt>: …
--   </pre>
VersionParseFailure :: !ParsingError -> CompileMetaError

-- | Throw a <a>CompileMetaError</a>.
throwCompileMetaError :: (MonadError CompileError m) => CompileMetaError -> m a

-- | Throw a generic catch-all <a>CompileMetaError</a>.
throwGenericCompileMetaError :: (MonadError CompileError m) => Text -> m a

-- | Throw a <a>VersionParseFailure</a> error.
throwVersionParseFailure :: (MonadError CompileError m) => ParsingError -> m a

-- | The type of errors encountered while compiling a Ninja phony
--   <tt>build</tt>.
data CompilePhonyError

-- | Generic catch-all error constructor. Avoid using this.
GenericCompilePhonyError :: !Text -> CompilePhonyError

-- | Throw a <a>CompilePhonyError</a>.
throwCompilePhonyError :: (MonadError CompileError m) => CompilePhonyError -> m a

-- | Throw a generic catch-all <a>CompilePhonyError</a>.
throwGenericCompilePhonyError :: (MonadError CompileError m) => Text -> m a

-- | The type of errors encountered while compiling a Ninja
--   <tt>default</tt> statement.
data CompileDefaultError

-- | Generic catch-all error constructor. Avoid using this.
GenericCompileDefaultError :: !Text -> CompileDefaultError

-- | Throw a <a>CompileDefaultError</a>.
throwCompileDefaultError :: (MonadError CompileError m) => CompileDefaultError -> m a

-- | Throw a generic catch-all <a>CompileDefaultError</a>.
throwGenericCompileDefaultError :: (MonadError CompileError m) => Text -> m a

-- | The type of errors encountered while compiling a Ninja <tt>build</tt>
--   statement.
data CompileBuildError

-- | Generic catch-all error constructor. Avoid using this.
GenericCompileBuildError :: !Text -> CompileBuildError

-- | <pre>
--   Rule not found: <a>text</a>
--   </pre>
BuildRuleNotFound :: !Text -> CompileBuildError

-- | Throw a <a>CompileBuildError</a>.
throwCompileBuildError :: (MonadError CompileError m) => CompileBuildError -> m a

-- | Throw a generic catch-all <a>CompileBuildError</a>.
throwGenericCompileBuildError :: (MonadError CompileError m) => Text -> m a

-- | Throw a <a>BuildRuleNotFound</a> error.
throwBuildRuleNotFound :: (MonadError CompileError m) => Text -> m a

-- | The type of errors encountered while compiling a Ninja <tt>rule</tt>
--   statement.
data CompileRuleError

-- | Generic catch-all error constructor. Avoid using this.
GenericCompileRuleError :: !Text -> CompileRuleError

-- | <pre>
--   Lookup failed on rule variable: <a>text</a>
--   </pre>
RuleLookupFailure :: !Text -> CompileRuleError

-- | <pre>
--   Unknown <tt>deps</tt> value: <a>text</a>
--   </pre>
UnknownDepsValue :: !Text -> CompileRuleError

-- | <pre>
--   Unexpected <tt>msvc_deps_prefix</tt> for `deps = "<a>text</a>"`
--   </pre>
UnexpectedMSVCPrefix :: !Text -> CompileRuleError

-- | Throw a <a>CompileRuleError</a>.
throwCompileRuleError :: (MonadError CompileError m) => CompileRuleError -> m a

-- | Throw a generic catch-all <a>CompileRuleError</a>.
throwGenericCompileRuleError :: (MonadError CompileError m) => Text -> m a

-- | Throw a <a>RuleLookupFailure</a> error.
throwRuleLookupFailure :: (MonadError CompileError m) => Text -> m a

-- | Throw an <tt>UnknownDeps</tt> error.
throwUnknownDeps :: (MonadError CompileError m) => Text -> m a

-- | Throw an <a>UnexpectedMSVCPrefix</a> error.
throwUnexpectedMSVCPrefix :: (MonadError CompileError m) => Text -> m a

-- | The type of errors encountered while compiling a Ninja <tt>pool</tt>
--   statement.
data CompilePoolError

-- | Generic catch-all error constructor. Avoid using this.
GenericCompilePoolError :: !Text -> CompilePoolError

-- | <pre>
--   Invalid pool depth for console: <a>int</a>
--   </pre>
InvalidPoolDepth :: !Int -> CompilePoolError

-- | <pre>
--   Pool name is an empty string
--   </pre>
EmptyPoolName :: CompilePoolError

-- | Throw a <a>CompilePoolError</a>.
throwCompilePoolError :: (MonadError CompileError m) => CompilePoolError -> m a

-- | Throw a generic catch-all <a>CompilePoolError</a>.
throwGenericCompilePoolError :: (MonadError CompileError m) => Text -> m a

-- | Throw an <a>InvalidPoolDepth</a> error.
throwInvalidPoolDepth :: (MonadError CompileError m) => Int -> m a

-- | Throw an <a>EmptyPoolName</a> error.
throwEmptyPoolName :: (MonadError CompileError m) => m a

-- | The type of errors encountered during parsing.
data ParseError

-- | Generic catch-all error constructor. Avoid using this.
GenericParseError :: !Text -> ParseError

-- | <pre>
--   Lexer failed at binding: <a>text</a>
--   </pre>
LexBindingFailure :: !Text -> ParseError

-- | <pre>
--   Expected a colon
--   </pre>
LexExpectedColon :: ParseError

-- | <pre>
--   Unexpected $ followed by unexpected stuff
--   </pre>
LexUnexpectedDollar :: ParseError

-- | Lexer expected a separator character but found something else
LexUnexpectedSeparator :: Char -> ParseError

-- | Any other lexer error.
LexParsecError :: !(ParseError Char Dec) -> ParseError

-- | <pre>
--   Could not parse depth field in pool, got: <a>text</a>
--   </pre>
ParseBadDepthField :: !Text -> ParseError

-- | <pre>
--   Unexpected binding defining <a>text</a>
--   </pre>
ParseUnexpectedBinding :: !Text -> ParseError

-- | Throw a <a>ParseError</a>.
throwParseError :: (MonadError ParseError m) => ParseError -> m a

-- | Throw a generic catch-all <a>ParseError</a>.
throwGenericParseError :: (MonadError ParseError m) => Text -> m a

-- | Throw a <a>LexBindingFailure</a> error.
throwLexBindingFailure :: (MonadError ParseError m) => Text -> m a

-- | Throw a <a>LexExpectedColon</a> error.
throwLexExpectedColon :: (MonadError ParseError m) => m a

-- | Throw a <tt>LexUnexpectedColon</tt> error.
throwLexUnexpectedDollar :: (MonadError ParseError m) => m a

-- | Throw a <a>LexUnexpectedSeparator</a> error.
throwLexUnexpectedSeparator :: (MonadError ParseError m) => Char -> m a

-- | Throw a <a>LexParsecError</a> error.
throwLexParsecError :: (MonadError ParseError m) => ParseError Char Dec -> m a

-- | Throw a <a>ParseBadDepthField</a> error.
throwParseBadDepthField :: (MonadError ParseError m) => Text -> m a

-- | Throw a <a>ParseUnexpectedBinding</a> error.
throwParseUnexpectedBinding :: (MonadError ParseError m) => Text -> m a
instance GHC.Generics.Generic Language.Ninja.Errors.NinjaError
instance GHC.Show.Show Language.Ninja.Errors.NinjaError
instance GHC.Classes.Eq Language.Ninja.Errors.NinjaError
instance GHC.Exception.Exception Language.Ninja.Errors.NinjaError


-- | This module contains a type representing a Ninja-style environment
--   along with any supporting or related types.
module Language.Ninja.AST.Env

-- | A Ninja-style environment, basically a nonempty list of hash tables.
data Env k v

-- | Construct an empty environment.
makeEnv :: Env k v

-- | An isomorphism between an <a>Env</a> and a nonempty list of
--   <a>HashMap</a>s.
fromEnv :: Iso' (Env k v) (Maps k v)

-- | Get the first <a>HashMap</a> in the underlying nonempty list.
headEnv :: Env k v -> HashMap k v

-- | If the remainder of the underlying nonempty list is nonempty, return
--   the remainder after <a>Env</a> wrapping. Otherwise, return
--   <a>Nothing</a>.
tailEnv :: Env k v -> Maybe (Env k v)

-- | Push a new <a>Env</a> onto the stack.
scopeEnv :: Env k v -> Env k v

-- | Add the given key and value to the given <a>Env</a>.
addEnv :: (Key k) => k -> v -> Env k v -> Env k v

-- | Look up the given key in the given <a>Env</a>.
askEnv :: (Key k) => Env k v -> k -> Maybe v

-- | The set of constraints required for a given constraint to be
--   automatically computed for an <a>Env</a>.
type EnvConstraint (c :: * -> Constraint) (k :: *) (v :: *) = (Key k, c k, c v, c (Maps k v))

-- | A constraint alias for <tt>(<a>Eq</a> k, <a>Hashable</a> k)</tt>.
type Key k = (Eq k, Hashable k)

-- | A <a>NonEmpty</a> list of <a>HashMap</a>s.
type Maps k v = NonEmpty (HashMap k v)
instance GHC.Generics.Generic (Language.Ninja.AST.Env.Env k v)
instance (GHC.Show.Show v, GHC.Show.Show k) => GHC.Show.Show (Language.Ninja.AST.Env.Env k v)
instance (GHC.Classes.Eq v, GHC.Classes.Eq k) => GHC.Classes.Eq (Language.Ninja.AST.Env.Env k v)
instance (Data.Aeson.Types.ToJSON.ToJSONKey k, Data.Aeson.Types.ToJSON.ToJSON v) => Data.Aeson.Types.ToJSON.ToJSON (Language.Ninja.AST.Env.Env k v)
instance (Language.Ninja.AST.Env.Key k, Data.Aeson.Types.FromJSON.FromJSONKey k, Data.Aeson.Types.FromJSON.FromJSON v) => Data.Aeson.Types.FromJSON.FromJSON (Language.Ninja.AST.Env.Env k v)
instance (Language.Ninja.AST.Env.Key k, Test.QuickCheck.Arbitrary.Arbitrary k, Test.QuickCheck.Arbitrary.Arbitrary v) => Test.QuickCheck.Arbitrary.Arbitrary (Language.Ninja.AST.Env.Env k v)
instance (Data.Hashable.Class.Hashable k, Data.Hashable.Class.Hashable v) => Data.Hashable.Class.Hashable (Language.Ninja.AST.Env.Env k v)
instance (Control.DeepSeq.NFData k, Control.DeepSeq.NFData v) => Control.DeepSeq.NFData (Language.Ninja.AST.Env.Env k v)
instance (GHC.Base.Monad m, Language.Ninja.AST.Env.EnvConstraint (Test.SmallCheck.Series.Serial m) k v) => Test.SmallCheck.Series.Serial m (Language.Ninja.AST.Env.Env k v)
instance (GHC.Base.Monad m, Language.Ninja.AST.Env.EnvConstraint (Test.SmallCheck.Series.CoSerial m) k v) => Test.SmallCheck.Series.CoSerial m (Language.Ninja.AST.Env.Env k v)


-- | This module contains a type representing a string that potentially
--   contains variable references in the parsed Ninja AST, along with any
--   supporting or related types.
module Language.Ninja.AST.Expr

-- | An expression containing variable references in the Ninja language.
data Expr ann

-- | Sequencing of expressions.
Exprs :: !ann -> ![Expr ann] -> Expr ann

-- | A literal string.
Lit :: !ann -> !Text -> Expr ann

-- | A variable reference.
Var :: !ann -> !Text -> Expr ann

-- | A prism for the <a>Exprs</a> constructor.
_Exprs :: Prism' (Expr ann) (ann, [Expr ann])

-- | A prism for the <a>Lit</a> constructor.
_Lit :: Prism' (Expr ann) (ann, Text)

-- | A prism for the <a>Var</a> constructor.
_Var :: Prism' (Expr ann) (ann, Text)

-- | Look up the given variable in the given context, returning the empty
--   string if the variable was not found.
askVar :: Env Text Text -> Text -> Text

-- | Evaluate the given <a>Expr</a> in the given context (<tt><tt>Env</tt>
--   <a>Text</a> <a>Text</a></tt>).
askExpr :: Env Text Text -> Expr ann -> Text

-- | Add a binding with the given name (<a>Text</a>) and value
--   (<a>Expr</a>) to the given context.
addBind :: Text -> Expr ann -> Env Text Text -> Env Text Text

-- | Add bindings from a list. Note that this function evaluates all the
--   right-hand-sides first, and then adds them all to the environment.
--   
--   For example:
--   
--   <pre>
--   &gt;&gt;&gt; let binds = [("x", Lit "5"), ("y", Var "x")]
--   
--   &gt;&gt;&gt; AST.headEnv (addBinds binds AST.makeEnv)
--   fromList [("x","5"),("y","")]
--   </pre>
addBinds :: [(Text, Expr ann)] -> Env Text Text -> Env Text Text

-- | Normalize an <a>Expr</a> by recursively flattening any <a>Exprs</a>
--   nodes, removing empty <a>Lit</a> nodes, combining adjacent <a>Lit</a>
--   nodes, and pulling out the interior of the top-level <a>Exprs</a> node
--   if it has only one subnode.
--   
--   The number of <a>Exprs</a> nodes in the output is guaranteed to be 0
--   or 1.
--   
--   If it is 0, then there is exactly one node of any type in the output.
--   
--   The output is thus isomorphic to <tt>(Maybe ann, [(ann, Either Text
--   Text)])</tt>, where the <tt>Maybe ann</tt> represents the annotation
--   of the top-level <a>Exprs</a> node if it exists.
normalizeExpr :: forall ann. (Monoid ann) => Expr ann -> Expr ann

-- | The set of constraints required for a given constraint to be
--   automatically computed for a <a>Expr</a>.
type ExprConstraint (c :: * -> Constraint) (ann :: *) = (c Text, c ann)
instance Data.Traversable.Traversable Language.Ninja.AST.Expr.Expr
instance Data.Foldable.Foldable Language.Ninja.AST.Expr.Expr
instance GHC.Base.Functor Language.Ninja.AST.Expr.Expr
instance Data.Data.Data ann => Data.Data.Data (Language.Ninja.AST.Expr.Expr ann)
instance GHC.Generics.Generic (Language.Ninja.AST.Expr.Expr ann)
instance GHC.Show.Show ann => GHC.Show.Show (Language.Ninja.AST.Expr.Expr ann)
instance GHC.Classes.Eq ann => GHC.Classes.Eq (Language.Ninja.AST.Expr.Expr ann)
instance Data.Data.Data ann => Control.Lens.Plated.Plated (Language.Ninja.AST.Expr.Expr ann)
instance Language.Ninja.Misc.Annotated.Annotated Language.Ninja.AST.Expr.Expr
instance Data.Aeson.Types.ToJSON.ToJSON ann => Data.Aeson.Types.ToJSON.ToJSON (Language.Ninja.AST.Expr.Expr ann)
instance Data.Aeson.Types.FromJSON.FromJSON ann => Data.Aeson.Types.FromJSON.FromJSON (Language.Ninja.AST.Expr.Expr ann)
instance Test.QuickCheck.Arbitrary.Arbitrary ann => Test.QuickCheck.Arbitrary.Arbitrary (Language.Ninja.AST.Expr.Expr ann)
instance Data.Hashable.Class.Hashable ann => Data.Hashable.Class.Hashable (Language.Ninja.AST.Expr.Expr ann)
instance Control.DeepSeq.NFData ann => Control.DeepSeq.NFData (Language.Ninja.AST.Expr.Expr ann)
instance (GHC.Base.Monad m, Language.Ninja.AST.Expr.ExprConstraint (Test.SmallCheck.Series.Serial m) ann) => Test.SmallCheck.Series.Serial m (Language.Ninja.AST.Expr.Expr ann)
instance (GHC.Base.Monad m, Language.Ninja.AST.Expr.ExprConstraint (Test.SmallCheck.Series.CoSerial m) ann) => Test.SmallCheck.Series.CoSerial m (Language.Ninja.AST.Expr.Expr ann)


-- | This module contains a type representing a <tt>rule</tt> declaration
--   in the parsed Ninja AST, along with any supporting or related types.
module Language.Ninja.AST.Rule

-- | A parsed Ninja <tt>rule</tt> declaration.
data Rule ann

-- | Construct a <a>Rule</a> with all default values
makeRule :: (Monoid ann) => Rule ann

-- | The set of bindings in scope during the execution of this rule.
ruleBind :: Lens' (Rule ann) (HashMap Text (Expr ann))

-- | The set of constraints required for a given constraint to be
--   automatically computed for a <a>Rule</a>.
type RuleConstraint (c :: * -> Constraint) (ann :: *) = (c (HashMap Text (Expr ann)), c ann)
instance Data.Traversable.Traversable Language.Ninja.AST.Rule.Rule
instance Data.Foldable.Foldable Language.Ninja.AST.Rule.Rule
instance GHC.Base.Functor Language.Ninja.AST.Rule.Rule
instance GHC.Generics.Generic (Language.Ninja.AST.Rule.Rule ann)
instance GHC.Show.Show ann => GHC.Show.Show (Language.Ninja.AST.Rule.Rule ann)
instance GHC.Classes.Eq ann => GHC.Classes.Eq (Language.Ninja.AST.Rule.Rule ann)
instance Language.Ninja.Misc.Annotated.Annotated Language.Ninja.AST.Rule.Rule
instance Data.Aeson.Types.ToJSON.ToJSON ann => Data.Aeson.Types.ToJSON.ToJSON (Language.Ninja.AST.Rule.Rule ann)
instance Data.Aeson.Types.FromJSON.FromJSON ann => Data.Aeson.Types.FromJSON.FromJSON (Language.Ninja.AST.Rule.Rule ann)
instance Test.QuickCheck.Arbitrary.Arbitrary ann => Test.QuickCheck.Arbitrary.Arbitrary (Language.Ninja.AST.Rule.Rule ann)
instance Data.Hashable.Class.Hashable ann => Data.Hashable.Class.Hashable (Language.Ninja.AST.Rule.Rule ann)
instance Control.DeepSeq.NFData ann => Control.DeepSeq.NFData (Language.Ninja.AST.Rule.Rule ann)
instance (GHC.Base.Monad m, Language.Ninja.AST.Rule.RuleConstraint (Test.SmallCheck.Series.Serial m) ann) => Test.SmallCheck.Series.Serial m (Language.Ninja.AST.Rule.Rule ann)
instance (GHC.Base.Monad m, Language.Ninja.AST.Rule.RuleConstraint (Test.SmallCheck.Series.CoSerial m) ann) => Test.SmallCheck.Series.CoSerial m (Language.Ninja.AST.Rule.Rule ann)


-- | This module contains a type representing the dependencies of a
--   <tt>build</tt> declaration in the parsed Ninja AST, along with any
--   supporting or related types.
module Language.Ninja.AST.Deps

-- | A set of Ninja build dependencies.
data Deps ann

-- | Construct a <a>Deps</a> with all default values
makeDeps :: (Monoid ann) => Deps ann

-- | A lens into the set of normal dependencies in a <a>Deps</a>.
depsNormal :: Lens' (Deps ann) (HashSet Text)

-- | A lens into the set of implicit dependencies in a <a>Deps</a>.
depsImplicit :: Lens' (Deps ann) (HashSet Text)

-- | A lens into the set of order-only dependencies in a <a>Deps</a>.
depsOrderOnly :: Lens' (Deps ann) (HashSet Text)

-- | The set of constraints required for a given constraint to be
--   automatically computed for a <tt>Ninja</tt>.
type DepsConstraint (c :: * -> Constraint) (ann :: *) = (c (HashSet Text), c ann)
instance Data.Traversable.Traversable Language.Ninja.AST.Deps.Deps
instance Data.Foldable.Foldable Language.Ninja.AST.Deps.Deps
instance GHC.Base.Functor Language.Ninja.AST.Deps.Deps
instance GHC.Generics.Generic (Language.Ninja.AST.Deps.Deps ann)
instance GHC.Show.Show ann => GHC.Show.Show (Language.Ninja.AST.Deps.Deps ann)
instance GHC.Classes.Eq ann => GHC.Classes.Eq (Language.Ninja.AST.Deps.Deps ann)
instance Language.Ninja.Misc.Annotated.Annotated Language.Ninja.AST.Deps.Deps
instance Data.Aeson.Types.ToJSON.ToJSON ann => Data.Aeson.Types.ToJSON.ToJSON (Language.Ninja.AST.Deps.Deps ann)
instance Data.Aeson.Types.FromJSON.FromJSON ann => Data.Aeson.Types.FromJSON.FromJSON (Language.Ninja.AST.Deps.Deps ann)
instance Test.QuickCheck.Arbitrary.Arbitrary ann => Test.QuickCheck.Arbitrary.Arbitrary (Language.Ninja.AST.Deps.Deps ann)
instance Data.Hashable.Class.Hashable ann => Data.Hashable.Class.Hashable (Language.Ninja.AST.Deps.Deps ann)
instance Control.DeepSeq.NFData ann => Control.DeepSeq.NFData (Language.Ninja.AST.Deps.Deps ann)
instance (GHC.Base.Monad m, Language.Ninja.AST.Deps.DepsConstraint (Test.SmallCheck.Series.Serial m) ann) => Test.SmallCheck.Series.Serial m (Language.Ninja.AST.Deps.Deps ann)
instance (GHC.Base.Monad m, Language.Ninja.AST.Deps.DepsConstraint (Test.SmallCheck.Series.CoSerial m) ann) => Test.SmallCheck.Series.CoSerial m (Language.Ninja.AST.Deps.Deps ann)


-- | This module contains a type representing a <tt>build</tt> declaration
--   in the parsed Ninja AST, along with any supporting or related types.
module Language.Ninja.AST.Build

-- | A parsed Ninja <tt>build</tt> declaration.
data Build ann

-- | Construct a <a>Build</a> with all default values.
makeBuild :: (Monoid ann) => Text -> Env Text Text -> Build ann

-- | A lens into the rule name associated with a <a>Build</a>.
buildRule :: Lens' (Build ann) Text

-- | A lens into the environment associated with a <a>Build</a>.
buildEnv :: Lens' (Build ann) (Env Text Text)

-- | A lens into the dependencies associated with a <a>Build</a>.
buildDeps :: Lens' (Build ann) (Deps ann)

-- | A lens into the bindings associated with a <a>Build</a>.
buildBind :: Lens' (Build ann) (HashMap Text Text)

-- | The set of constraints required for a given constraint to be
--   automatically computed for a <a>Build</a>.
type BuildConstraint (c :: * -> Constraint) (ann :: *) = (DepsConstraint c ann, c Text, c (HashMap Text Text), c (Maps Text Text), c ann)
instance Data.Traversable.Traversable Language.Ninja.AST.Build.Build
instance Data.Foldable.Foldable Language.Ninja.AST.Build.Build
instance GHC.Base.Functor Language.Ninja.AST.Build.Build
instance GHC.Generics.Generic (Language.Ninja.AST.Build.Build ann)
instance GHC.Show.Show ann => GHC.Show.Show (Language.Ninja.AST.Build.Build ann)
instance GHC.Classes.Eq ann => GHC.Classes.Eq (Language.Ninja.AST.Build.Build ann)
instance Language.Ninja.Misc.Annotated.Annotated Language.Ninja.AST.Build.Build
instance Data.Aeson.Types.ToJSON.ToJSON ann => Data.Aeson.Types.ToJSON.ToJSON (Language.Ninja.AST.Build.Build ann)
instance Data.Aeson.Types.FromJSON.FromJSON ann => Data.Aeson.Types.FromJSON.FromJSON (Language.Ninja.AST.Build.Build ann)
instance Test.QuickCheck.Arbitrary.Arbitrary ann => Test.QuickCheck.Arbitrary.Arbitrary (Language.Ninja.AST.Build.Build ann)
instance Data.Hashable.Class.Hashable ann => Data.Hashable.Class.Hashable (Language.Ninja.AST.Build.Build ann)
instance Control.DeepSeq.NFData ann => Control.DeepSeq.NFData (Language.Ninja.AST.Build.Build ann)
instance (GHC.Base.Monad m, Language.Ninja.AST.Build.BuildConstraint (Test.SmallCheck.Series.Serial m) ann) => Test.SmallCheck.Series.Serial m (Language.Ninja.AST.Build.Build ann)
instance (GHC.Base.Monad m, Language.Ninja.AST.Build.BuildConstraint (Test.SmallCheck.Series.CoSerial m) ann) => Test.SmallCheck.Series.CoSerial m (Language.Ninja.AST.Build.Build ann)


-- | This module contains a type representing a parsed Ninja file AST,
--   along with any supporting or related types.
module Language.Ninja.AST.Ninja

-- | A parsed Ninja file.
data Ninja ann

-- | Construct a <a>Ninja</a> with all default values
makeNinja :: (Monoid ann) => Ninja ann

-- | The rules defined in a parsed Ninja file.
ninjaRules :: Lens' (Ninja ann) (HashMap Text (Rule ann))

-- | The set of <tt>build</tt> declarations with precisely one output.
ninjaSingles :: Lens' (Ninja ann) (HashMap Text (Build ann))

-- | The set of <tt>build</tt> declarations with two or more outputs.
ninjaMultiples :: Lens' (Ninja ann) (HashMap Outputs (Build ann))

-- | The set of phony <tt>build</tt> declarations.
ninjaPhonys :: Lens' (Ninja ann) (HashMap Text (HashSet Text))

-- | The set of default targets.
ninjaDefaults :: Lens' (Ninja ann) (HashSet Text)

-- | A mapping from pool names to pool depth integers.
ninjaPools :: Lens' (Ninja ann) (HashMap Text Int)

-- | A map from "special" top-level variables to their values.
ninjaSpecials :: Lens' (Ninja ann) (HashMap Text Text)

-- | The set of constraints required for a given constraint to be
--   automatically computed for a <a>Ninja</a>.
type NinjaConstraint (c :: * -> Constraint) (ann :: *) = (BuildConstraint c ann, c (HashMap (HashSet Text) (Build ann)), c (HashMap Text (HashSet Text)), c (HashMap Text (Rule ann)), c (HashMap Text (Build ann)), c (HashMap Text Int), c ann)

-- | A type representing the set of outputs for a <tt>build</tt>
--   declaration with multiple outputs.
type Outputs = HashSet Output

-- | A type representing an output of a <tt>build</tt> declaration.
type Output = Text
instance Data.Traversable.Traversable Language.Ninja.AST.Ninja.Ninja
instance Data.Foldable.Foldable Language.Ninja.AST.Ninja.Ninja
instance GHC.Base.Functor Language.Ninja.AST.Ninja.Ninja
instance GHC.Generics.Generic (Language.Ninja.AST.Ninja.Ninja ann)
instance GHC.Show.Show ann => GHC.Show.Show (Language.Ninja.AST.Ninja.Ninja ann)
instance GHC.Classes.Eq ann => GHC.Classes.Eq (Language.Ninja.AST.Ninja.Ninja ann)
instance Language.Ninja.Misc.Annotated.Annotated Language.Ninja.AST.Ninja.Ninja
instance Data.Aeson.Types.ToJSON.ToJSON ann => Data.Aeson.Types.ToJSON.ToJSON (Language.Ninja.AST.Ninja.Ninja ann)
instance Data.Aeson.Types.FromJSON.FromJSON ann => Data.Aeson.Types.FromJSON.FromJSON (Language.Ninja.AST.Ninja.Ninja ann)
instance Test.QuickCheck.Arbitrary.Arbitrary ann => Test.QuickCheck.Arbitrary.Arbitrary (Language.Ninja.AST.Ninja.Ninja ann)
instance Data.Hashable.Class.Hashable ann => Data.Hashable.Class.Hashable (Language.Ninja.AST.Ninja.Ninja ann)
instance Control.DeepSeq.NFData ann => Control.DeepSeq.NFData (Language.Ninja.AST.Ninja.Ninja ann)
instance (GHC.Base.Monad m, Language.Ninja.AST.Ninja.NinjaConstraint (Test.SmallCheck.Series.Serial m) ann) => Test.SmallCheck.Series.Serial m (Language.Ninja.AST.Ninja.Ninja ann)
instance (GHC.Base.Monad m, Language.Ninja.AST.Ninja.NinjaConstraint (Test.SmallCheck.Series.CoSerial m) ann) => Test.SmallCheck.Series.CoSerial m (Language.Ninja.AST.Ninja.Ninja ann)


-- | The Ninja build language after parsing.
--   
--   This module re-exports all of the modules under the
--   <a>Language.Ninja.AST</a> namespace for convenience.
--   
--   It is recommended that you import it with the following style:
--   
--   <pre>
--   import qualified Language.Ninja.AST as AST
--   </pre>
module Language.Ninja.AST

-- | A parsed Ninja file.
data Ninja ann

-- | Construct a <a>Ninja</a> with all default values
makeNinja :: (Monoid ann) => Ninja ann

-- | The rules defined in a parsed Ninja file.
ninjaRules :: Lens' (Ninja ann) (HashMap Text (Rule ann))

-- | The set of <tt>build</tt> declarations with precisely one output.
ninjaSingles :: Lens' (Ninja ann) (HashMap Text (Build ann))

-- | The set of <tt>build</tt> declarations with two or more outputs.
ninjaMultiples :: Lens' (Ninja ann) (HashMap Outputs (Build ann))

-- | The set of phony <tt>build</tt> declarations.
ninjaPhonys :: Lens' (Ninja ann) (HashMap Text (HashSet Text))

-- | The set of default targets.
ninjaDefaults :: Lens' (Ninja ann) (HashSet Text)

-- | A mapping from pool names to pool depth integers.
ninjaPools :: Lens' (Ninja ann) (HashMap Text Int)

-- | A map from "special" top-level variables to their values.
ninjaSpecials :: Lens' (Ninja ann) (HashMap Text Text)

-- | A parsed Ninja <tt>build</tt> declaration.
data Build ann

-- | Construct a <a>Build</a> with all default values.
makeBuild :: (Monoid ann) => Text -> Env Text Text -> Build ann

-- | A lens into the rule name associated with a <a>Build</a>.
buildRule :: Lens' (Build ann) Text

-- | A lens into the environment associated with a <a>Build</a>.
buildEnv :: Lens' (Build ann) (Env Text Text)

-- | A lens into the dependencies associated with a <a>Build</a>.
buildDeps :: Lens' (Build ann) (Deps ann)

-- | A lens into the bindings associated with a <a>Build</a>.
buildBind :: Lens' (Build ann) (HashMap Text Text)

-- | A set of Ninja build dependencies.
data Deps ann

-- | Construct a <a>Deps</a> with all default values
makeDeps :: (Monoid ann) => Deps ann

-- | A lens into the set of normal dependencies in a <a>Deps</a>.
depsNormal :: Lens' (Deps ann) (HashSet Text)

-- | A lens into the set of implicit dependencies in a <a>Deps</a>.
depsImplicit :: Lens' (Deps ann) (HashSet Text)

-- | A lens into the set of order-only dependencies in a <a>Deps</a>.
depsOrderOnly :: Lens' (Deps ann) (HashSet Text)

-- | A parsed Ninja <tt>rule</tt> declaration.
data Rule ann

-- | Construct a <a>Rule</a> with all default values
makeRule :: (Monoid ann) => Rule ann

-- | The set of bindings in scope during the execution of this rule.
ruleBind :: Lens' (Rule ann) (HashMap Text (Expr ann))

-- | An expression containing variable references in the Ninja language.
data Expr ann

-- | Sequencing of expressions.
Exprs :: !ann -> ![Expr ann] -> Expr ann

-- | A literal string.
Lit :: !ann -> !Text -> Expr ann

-- | A variable reference.
Var :: !ann -> !Text -> Expr ann

-- | A prism for the <a>Exprs</a> constructor.
_Exprs :: Prism' (Expr ann) (ann, [Expr ann])

-- | A prism for the <a>Lit</a> constructor.
_Lit :: Prism' (Expr ann) (ann, Text)

-- | A prism for the <a>Var</a> constructor.
_Var :: Prism' (Expr ann) (ann, Text)

-- | Look up the given variable in the given context, returning the empty
--   string if the variable was not found.
askVar :: Env Text Text -> Text -> Text

-- | Evaluate the given <a>Expr</a> in the given context (<tt><tt>Env</tt>
--   <a>Text</a> <a>Text</a></tt>).
askExpr :: Env Text Text -> Expr ann -> Text

-- | Add a binding with the given name (<a>Text</a>) and value
--   (<a>Expr</a>) to the given context.
addBind :: Text -> Expr ann -> Env Text Text -> Env Text Text

-- | Add bindings from a list. Note that this function evaluates all the
--   right-hand-sides first, and then adds them all to the environment.
--   
--   For example:
--   
--   <pre>
--   &gt;&gt;&gt; let binds = [("x", Lit "5"), ("y", Var "x")]
--   
--   &gt;&gt;&gt; AST.headEnv (addBinds binds AST.makeEnv)
--   fromList [("x","5"),("y","")]
--   </pre>
addBinds :: [(Text, Expr ann)] -> Env Text Text -> Env Text Text

-- | Normalize an <a>Expr</a> by recursively flattening any <a>Exprs</a>
--   nodes, removing empty <a>Lit</a> nodes, combining adjacent <a>Lit</a>
--   nodes, and pulling out the interior of the top-level <a>Exprs</a> node
--   if it has only one subnode.
--   
--   The number of <a>Exprs</a> nodes in the output is guaranteed to be 0
--   or 1.
--   
--   If it is 0, then there is exactly one node of any type in the output.
--   
--   The output is thus isomorphic to <tt>(Maybe ann, [(ann, Either Text
--   Text)])</tt>, where the <tt>Maybe ann</tt> represents the annotation
--   of the top-level <a>Exprs</a> node if it exists.
normalizeExpr :: forall ann. (Monoid ann) => Expr ann -> Expr ann

-- | A Ninja-style environment, basically a nonempty list of hash tables.
data Env k v

-- | Construct an empty environment.
makeEnv :: Env k v

-- | An isomorphism between an <a>Env</a> and a nonempty list of
--   <a>HashMap</a>s.
fromEnv :: Iso' (Env k v) (Maps k v)

-- | Add the given key and value to the given <a>Env</a>.
addEnv :: (Key k) => k -> v -> Env k v -> Env k v

-- | Look up the given key in the given <a>Env</a>.
askEnv :: (Key k) => Env k v -> k -> Maybe v

-- | Push a new <a>Env</a> onto the stack.
scopeEnv :: Env k v -> Env k v


-- | Compile a parsed Ninja file into an intermediate representation.
module Language.Ninja.Compile

-- | Compile an parsed Ninja file into a intermediate representation.
compile :: forall m ann. (MonadError CompileError m) => Ninja ann -> m Ninja


-- | Lexing is a slow point, the code below is optimised.
module Language.Ninja.Lexer

-- | Lex the given file.
lexerFile :: (MonadError ParseError m, MonadReadFile m) => Path -> m [Lexeme Ann]

-- | Lex the given <a>Text</a>.
lexerText :: (MonadError ParseError m) => Text -> m [Lexeme Ann]

-- | Lex the given <a>ByteString</a>.
lexerBS :: (MonadError ParseError m) => ByteString -> m [Lexeme Ann]

-- | Lex the given <a>Text</a> that comes from the given <a>Path</a>, if
--   provided.
lexerText' :: (MonadError ParseError m) => Maybe Path -> Text -> m [Lexeme Ann]

-- | Lex the given <a>ByteString</a> that comes from the given <a>Path</a>,
--   if it is provided. The <a>Path</a> is only used for error messages.
lexerBS' :: (MonadError ParseError m) => Maybe Path -> ByteString -> m [Lexeme Ann]

-- | The <tt>megaparsec</tt> parser for a Ninja file.
lexemesP :: Parser m [Lexeme Ann]

-- | A <tt>megaparsec</tt> parser.
type Parser m a = ParsecT Dec Text m a

-- | The type of annotations returned by the lexer.
type Ann = Spans

-- | Lex each line separately, rather than each lexeme.
data Lexeme ann

-- | <pre>
--   foo = bar
--   </pre>
LexDefine :: !ann -> !(LBind ann) -> Lexeme ann

-- | <pre>
--   [indent]foo = bar
--   </pre>
LexBind :: !ann -> !(LBind ann) -> Lexeme ann

-- | <pre>
--   include file
--   </pre>
LexInclude :: !ann -> !(LFile ann) -> Lexeme ann

-- | <pre>
--   subninja file
--   </pre>
LexSubninja :: !ann -> !(LFile ann) -> Lexeme ann

-- | <pre>
--   build foo: bar | baz || qux
--   </pre>
LexBuild :: !ann -> !(LBuild ann) -> Lexeme ann

-- | <pre>
--   rule name
--   </pre>
LexRule :: !ann -> !(LName ann) -> Lexeme ann

-- | <pre>
--   pool name
--   </pre>
LexPool :: !ann -> !(LName ann) -> Lexeme ann

-- | <pre>
--   default foo bar
--   </pre>
LexDefault :: !ann -> ![Expr ann] -> Lexeme ann

-- | The name of a Ninja rule or pool.
data LName ann
MkLName :: !ann -> !ByteString -> LName ann
[_lnameAnn] :: LName ann -> !ann
[_lnameBS] :: LName ann -> !ByteString

-- | A reference to a file in an <tt>include</tt> or <tt>subninja</tt>
--   declaration.
newtype LFile ann
MkLFile :: Expr ann -> LFile ann
[_lfileExpr] :: LFile ann -> Expr ann

-- | A Ninja variable binding, top-level or otherwise.
data LBind ann
MkLBind :: !ann -> !(LName ann) -> !(Expr ann) -> LBind ann
[_lbindAnn] :: LBind ann -> !ann
[_lbindName] :: LBind ann -> !(LName ann)
[_lbindValue] :: LBind ann -> !(Expr ann)

-- | The data contained within a Ninja <tt>build</tt> declaration.
data LBuild ann
MkLBuild :: !ann -> ![Expr ann] -> !(LName ann) -> ![Expr ann] -> LBuild ann
[_lbuildAnn] :: LBuild ann -> !ann
[_lbuildOuts] :: LBuild ann -> ![Expr ann]
[_lbuildRule] :: LBuild ann -> !(LName ann)
[_lbuildDeps] :: LBuild ann -> ![Expr ann]

-- | Constructor for an <a>LBuild</a>.
makeLBuild :: forall ann. ann -> [Expr ann] -> LName ann -> [Expr ann] -> LBuild ann

-- | The set of constraints required for a given constraint to be
--   automatically computed for an <a>Lexeme</a>.
type LexemeConstraint (c :: * -> Constraint) (ann :: *) = (LBindConstraint c ann, LFileConstraint c ann, LBuildConstraint c ann, LNameConstraint c ann, c [Expr ann], c ann)

-- | The set of constraints required for a given constraint to be
--   automatically computed for an <a>LName</a>.
type LNameConstraint (c :: * -> Constraint) (ann :: *) = (c Text, c ann)

-- | The set of constraints required for a given constraint to be
--   automatically computed for an <a>LFile</a>.
type LFileConstraint (c :: * -> Constraint) (ann :: *) = (c Text, c ann)

-- | The set of constraints required for a given constraint to be
--   automatically computed for an <a>LBind</a>.
type LBindConstraint (c :: * -> Constraint) (ann :: *) = (c Text, c ann)

-- | The set of constraints required for a given constraint to be
--   automatically computed for an <a>LBuild</a>.
type LBuildConstraint (c :: * -> Constraint) (ann :: *) = (c Text, c ann)

-- | This class is kind of like <tt>DeltaParsing</tt> from
--   <tt>trifecta</tt>.
class (Monad m) => PositionParsing m
getPosition :: PositionParsing m => m Position
instance Data.Traversable.Traversable Language.Ninja.Lexer.Lexeme
instance Data.Foldable.Foldable Language.Ninja.Lexer.Lexeme
instance GHC.Base.Functor Language.Ninja.Lexer.Lexeme
instance GHC.Generics.Generic (Language.Ninja.Lexer.Lexeme ann)
instance GHC.Show.Show ann => GHC.Show.Show (Language.Ninja.Lexer.Lexeme ann)
instance GHC.Classes.Eq ann => GHC.Classes.Eq (Language.Ninja.Lexer.Lexeme ann)
instance Data.Traversable.Traversable Language.Ninja.Lexer.LBuild
instance Data.Foldable.Foldable Language.Ninja.Lexer.LBuild
instance GHC.Base.Functor Language.Ninja.Lexer.LBuild
instance GHC.Generics.Generic (Language.Ninja.Lexer.LBuild ann)
instance GHC.Show.Show ann => GHC.Show.Show (Language.Ninja.Lexer.LBuild ann)
instance GHC.Classes.Eq ann => GHC.Classes.Eq (Language.Ninja.Lexer.LBuild ann)
instance Data.Traversable.Traversable Language.Ninja.Lexer.LBind
instance Data.Foldable.Foldable Language.Ninja.Lexer.LBind
instance GHC.Base.Functor Language.Ninja.Lexer.LBind
instance GHC.Generics.Generic (Language.Ninja.Lexer.LBind ann)
instance GHC.Show.Show ann => GHC.Show.Show (Language.Ninja.Lexer.LBind ann)
instance GHC.Classes.Eq ann => GHC.Classes.Eq (Language.Ninja.Lexer.LBind ann)
instance Data.Traversable.Traversable Language.Ninja.Lexer.LFile
instance Data.Foldable.Foldable Language.Ninja.Lexer.LFile
instance GHC.Base.Functor Language.Ninja.Lexer.LFile
instance GHC.Generics.Generic (Language.Ninja.Lexer.LFile ann)
instance GHC.Show.Show ann => GHC.Show.Show (Language.Ninja.Lexer.LFile ann)
instance GHC.Classes.Eq ann => GHC.Classes.Eq (Language.Ninja.Lexer.LFile ann)
instance Data.Traversable.Traversable Language.Ninja.Lexer.LName
instance Data.Foldable.Foldable Language.Ninja.Lexer.LName
instance GHC.Base.Functor Language.Ninja.Lexer.LName
instance GHC.Generics.Generic (Language.Ninja.Lexer.LName ann)
instance GHC.Show.Show ann => GHC.Show.Show (Language.Ninja.Lexer.LName ann)
instance GHC.Classes.Eq ann => GHC.Classes.Eq (Language.Ninja.Lexer.LName ann)
instance Language.Ninja.Misc.Annotated.Annotated Language.Ninja.Lexer.Lexeme
instance Data.Aeson.Types.ToJSON.ToJSON ann => Data.Aeson.Types.ToJSON.ToJSON (Language.Ninja.Lexer.Lexeme ann)
instance Data.Aeson.Types.FromJSON.FromJSON ann => Data.Aeson.Types.FromJSON.FromJSON (Language.Ninja.Lexer.Lexeme ann)
instance Data.Hashable.Class.Hashable ann => Data.Hashable.Class.Hashable (Language.Ninja.Lexer.Lexeme ann)
instance Control.DeepSeq.NFData ann => Control.DeepSeq.NFData (Language.Ninja.Lexer.Lexeme ann)
instance (GHC.Base.Monad m, Language.Ninja.Lexer.LexemeConstraint (Test.SmallCheck.Series.Serial m) ann) => Test.SmallCheck.Series.Serial m (Language.Ninja.Lexer.Lexeme ann)
instance (GHC.Base.Monad m, Language.Ninja.Lexer.LexemeConstraint (Test.SmallCheck.Series.CoSerial m) ann) => Test.SmallCheck.Series.CoSerial m (Language.Ninja.Lexer.Lexeme ann)
instance Language.Ninja.Misc.Annotated.Annotated Language.Ninja.Lexer.LName
instance Data.Aeson.Types.ToJSON.ToJSON ann => Data.Aeson.Types.ToJSON.ToJSON (Language.Ninja.Lexer.LName ann)
instance Data.Aeson.Types.FromJSON.FromJSON ann => Data.Aeson.Types.FromJSON.FromJSON (Language.Ninja.Lexer.LName ann)
instance Data.Hashable.Class.Hashable ann => Data.Hashable.Class.Hashable (Language.Ninja.Lexer.LName ann)
instance Control.DeepSeq.NFData ann => Control.DeepSeq.NFData (Language.Ninja.Lexer.LName ann)
instance (GHC.Base.Monad m, Language.Ninja.Lexer.LNameConstraint (Test.SmallCheck.Series.Serial m) ann) => Test.SmallCheck.Series.Serial m (Language.Ninja.Lexer.LName ann)
instance (GHC.Base.Monad m, Language.Ninja.Lexer.LNameConstraint (Test.SmallCheck.Series.CoSerial m) ann) => Test.SmallCheck.Series.CoSerial m (Language.Ninja.Lexer.LName ann)
instance Data.Aeson.Types.ToJSON.ToJSON ann => Data.Aeson.Types.ToJSON.ToJSON (Language.Ninja.Lexer.LFile ann)
instance Data.Aeson.Types.FromJSON.FromJSON ann => Data.Aeson.Types.FromJSON.FromJSON (Language.Ninja.Lexer.LFile ann)
instance Data.Hashable.Class.Hashable ann => Data.Hashable.Class.Hashable (Language.Ninja.Lexer.LFile ann)
instance Control.DeepSeq.NFData ann => Control.DeepSeq.NFData (Language.Ninja.Lexer.LFile ann)
instance (GHC.Base.Monad m, Language.Ninja.Lexer.LFileConstraint (Test.SmallCheck.Series.Serial m) ann) => Test.SmallCheck.Series.Serial m (Language.Ninja.Lexer.LFile ann)
instance (GHC.Base.Monad m, Language.Ninja.Lexer.LFileConstraint (Test.SmallCheck.Series.CoSerial m) ann) => Test.SmallCheck.Series.CoSerial m (Language.Ninja.Lexer.LFile ann)
instance Data.Aeson.Types.ToJSON.ToJSON ann => Data.Aeson.Types.ToJSON.ToJSON (Language.Ninja.Lexer.LBind ann)
instance Data.Aeson.Types.FromJSON.FromJSON ann => Data.Aeson.Types.FromJSON.FromJSON (Language.Ninja.Lexer.LBind ann)
instance Data.Hashable.Class.Hashable ann => Data.Hashable.Class.Hashable (Language.Ninja.Lexer.LBind ann)
instance Control.DeepSeq.NFData ann => Control.DeepSeq.NFData (Language.Ninja.Lexer.LBind ann)
instance (GHC.Base.Monad m, Language.Ninja.Lexer.LBindConstraint (Test.SmallCheck.Series.Serial m) ann) => Test.SmallCheck.Series.Serial m (Language.Ninja.Lexer.LBind ann)
instance (GHC.Base.Monad m, Language.Ninja.Lexer.LBindConstraint (Test.SmallCheck.Series.CoSerial m) ann) => Test.SmallCheck.Series.CoSerial m (Language.Ninja.Lexer.LBind ann)
instance Language.Ninja.Misc.Annotated.Annotated Language.Ninja.Lexer.LBuild
instance Data.Aeson.Types.ToJSON.ToJSON ann => Data.Aeson.Types.ToJSON.ToJSON (Language.Ninja.Lexer.LBuild ann)
instance Data.Aeson.Types.FromJSON.FromJSON ann => Data.Aeson.Types.FromJSON.FromJSON (Language.Ninja.Lexer.LBuild ann)
instance Data.Hashable.Class.Hashable ann => Data.Hashable.Class.Hashable (Language.Ninja.Lexer.LBuild ann)
instance Control.DeepSeq.NFData ann => Control.DeepSeq.NFData (Language.Ninja.Lexer.LBuild ann)
instance (GHC.Base.Monad m, Language.Ninja.Lexer.LBuildConstraint (Test.SmallCheck.Series.Serial m) ann) => Test.SmallCheck.Series.Serial m (Language.Ninja.Lexer.LBuild ann)
instance (GHC.Base.Monad m, Language.Ninja.Lexer.LBuildConstraint (Test.SmallCheck.Series.CoSerial m) ann) => Test.SmallCheck.Series.CoSerial m (Language.Ninja.Lexer.LBuild ann)
instance Language.Ninja.Lexer.PositionParsing (Text.Megaparsec.Prim.ParsecT Text.Megaparsec.Error.Dec Data.Text.Internal.Text m)


-- | Parse a Ninja file.
module Language.Ninja.Parser

-- | Parse the file at the given path into a <a>Ninja</a>. This function
--   may throw an exception if parsing fails.
parseFileIO :: Path -> IO (Ninja Ann)

-- | Parse the given <a>Text</a> into a <a>Ninja</a>. This function may
--   throw an exception if parsing fails.
parseTextIO :: Text -> IO (Ninja Ann)

-- | Parse the given <a>ByteString</a> into a <a>Ninja</a>. This function
--   may throw an exception if parsing fails.
parseBSIO :: ByteString -> IO (Ninja Ann)

-- | Parse the given list of <a>Lexeme</a>s into a <a>Ninja</a>. This
--   function may throw an exception if parsing fails.
parseLexemesIO :: [Lexeme Ann] -> IO (Ninja Ann)

-- | Parse the file at the given path into a <a>Ninja</a>.
parseFile :: (MonadError ParseError m, MonadReadFile m) => Path -> m (Ninja Ann)

-- | Parse the given <a>Text</a> into a <a>Ninja</a>.
parseText :: (MonadError ParseError m, MonadReadFile m) => Text -> m (Ninja Ann)

-- | Parse the given <a>ByteString</a> into a <a>Ninja</a>.
parseBS :: (MonadError ParseError m, MonadReadFile m) => ByteString -> m (Ninja Ann)

-- | Parse the given list of <a>Lexeme</a>s into a <a>Ninja</a>.
parseLexemes :: (MonadError ParseError m, MonadReadFile m) => [Lexeme Ann] -> m (Ninja Ann)

-- | Parse the file at the given path using the given Ninja variable
--   context, resulting in a <a>Ninja</a>.
parseFileWithEnv :: (MonadError ParseError m, MonadReadFile m) => Path -> Env Text Text -> m (Ninja Ann)

-- | Parse the given <a>Text</a> using the given Ninja variable context,
--   resulting in a <a>Ninja</a>.
parseTextWithEnv :: (MonadError ParseError m, MonadReadFile m) => Text -> Env Text Text -> m (Ninja Ann)

-- | Parse the given <a>ByteString</a> using the given Ninja variable
--   context, resulting in a <a>Ninja</a>.
parseBSWithEnv :: (MonadError ParseError m, MonadReadFile m) => ByteString -> Env Text Text -> m (Ninja Ann)

-- | Parse the given list of <a>Lexeme</a>s into a <a>Ninja</a>.
parseLexemesWithEnv :: (MonadError ParseError m, MonadReadFile m) => [Lexeme Ann] -> Env Text Text -> m (Ninja Ann)


-- | A rudimentary pretty-printer for <a>Ninja</a>.
module Language.Ninja.Pretty

-- | Pretty-print a <a>Ninja</a>.
prettyNinja :: Ninja () -> Text

-- | Pretty-print an <a>Expr</a>
prettyExpr :: Expr () -> Text

-- | Pretty-print a Ninja <tt>rule</tt> declaration.
prettyRule :: (Text, Rule ()) -> Text

-- | Pretty-print a Ninja <tt>build</tt> declaration with one output.
prettySingle :: (Text, Build ()) -> Text

-- | Pretty-print a Ninja <tt>build</tt> declaration with multiple outputs.
prettyMultiple :: (HashSet Text, Build ()) -> Text

-- | Pretty-print a Ninja phony <tt>build</tt> declaration.
prettyPhony :: (Text, HashSet Text) -> Text

-- | Pretty-print a Ninja <tt>default</tt> declaration.
prettyDefault :: Text -> Text

-- | Pretty-print a Ninja <tt>pool</tt> declaration.
prettyPool :: (Text, Int) -> Text

-- | Pretty-print a Ninja indented binding.
prettyBind :: (Text, Text) -> Text


-- | FIXME: doc
module Language.Ninja.Tutorial


-- | Tools for parsing, pretty-printing, and compiling the Ninja build
--   language.
--   
--   This module re-exports some of the modules under the
--   <a>Language.Ninja</a> namespace for convenience.
--   
--   Take a look at <a>Language.Ninja.Tutorial</a> for a tutorial on how to
--   use this library. If you just want to dive in, I recommend reading
--   these modules in the following order:
--   
--   <ol>
--   <li>Skim <a>Language.Ninja.Misc</a>, <a>Language.Ninja.Mock</a>, and
--   <a>Language.Ninja.Errors</a> for familiarity with types and values
--   that are used all over this library.</li>
--   <li>Check out <a>Language.Ninja.Lexer</a> and then
--   <a>Language.Ninja.Parser</a> to get an idea for what is possible with
--   the lexer/parser API.</li>
--   <li>Read <a>Language.Ninja.AST</a> to understand what the parsed AST
--   looks like.</li>
--   <li>Read <a>Language.Ninja.Compile</a> to see what the AST-to-IR
--   compiler does.</li>
--   <li>Read <a>Language.Ninja.IR</a> to understand what the compiled IR
--   looks like.</li>
--   <li>Read <a>Language.Ninja.Pretty</a> to see what the pretty-printer
--   is capable of (spoiler: not very much).</li>
--   </ol>
--   
--   If you are not already well-versed in the Ninja build language, it is
--   also probably worth reading the Ninja <a>manual</a>.
--   
--   When importing from this library, I recommend the following style:
--   
--   <pre>
--   import qualified Language.Ninja     as Ninja
--   import qualified Language.Ninja.AST as Ninja.AST
--   import qualified Language.Ninja.IR  as Ninja.IR
--   </pre>
--   
--   Happy hacking!
module Language.Ninja
