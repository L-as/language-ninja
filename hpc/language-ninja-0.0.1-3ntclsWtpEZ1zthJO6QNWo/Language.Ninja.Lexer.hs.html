<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="lineno">    1 </span>-- -*- coding: utf-8; mode: haskell; -*-
<span class="lineno">    2 </span>
<span class="lineno">    3 </span>-- File: library/Language/Ninja/Lexer.hs
<span class="lineno">    4 </span>--
<span class="lineno">    5 </span>-- License:
<span class="lineno">    6 </span>--     Copyright Neil Mitchell  2011-2017.
<span class="lineno">    7 </span>--     Copyright Awake Networks 2017.
<span class="lineno">    8 </span>--     All rights reserved.
<span class="lineno">    9 </span>--
<span class="lineno">   10 </span>--     Redistribution and use in source and binary forms, with or without
<span class="lineno">   11 </span>--     modification, are permitted provided that the following conditions are
<span class="lineno">   12 </span>--     met:
<span class="lineno">   13 </span>--
<span class="lineno">   14 </span>--         * Redistributions of source code must retain the above copyright
<span class="lineno">   15 </span>--           notice, this list of conditions and the following disclaimer.
<span class="lineno">   16 </span>--
<span class="lineno">   17 </span>--         * Redistributions in binary form must reproduce the above
<span class="lineno">   18 </span>--           copyright notice, this list of conditions and the following
<span class="lineno">   19 </span>--           disclaimer in the documentation and/or other materials provided
<span class="lineno">   20 </span>--           with the distribution.
<span class="lineno">   21 </span>--
<span class="lineno">   22 </span>--         * Neither the name of Neil Mitchell nor the names of other
<span class="lineno">   23 </span>--           contributors may be used to endorse or promote products derived
<span class="lineno">   24 </span>--           from this software without specific prior written permission.
<span class="lineno">   25 </span>--
<span class="lineno">   26 </span>--     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
<span class="lineno">   27 </span>--     &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
<span class="lineno">   28 </span>--     LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
<span class="lineno">   29 </span>--     A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
<span class="lineno">   30 </span>--     OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
<span class="lineno">   31 </span>--     SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
<span class="lineno">   32 </span>--     LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
<span class="lineno">   33 </span>--     DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
<span class="lineno">   34 </span>--     THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
<span class="lineno">   35 </span>--     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
<span class="lineno">   36 </span>--     OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<span class="lineno">   37 </span>
<span class="lineno">   38 </span>{-# OPTIONS_GHC -fno-warn-unused-do-bind #-}
<span class="lineno">   39 </span>
<span class="lineno">   40 </span>{-# LANGUAGE ConstraintKinds            #-}
<span class="lineno">   41 </span>{-# LANGUAGE DeriveFunctor              #-}
<span class="lineno">   42 </span>{-# LANGUAGE DeriveGeneric              #-}
<span class="lineno">   43 </span>{-# LANGUAGE DeriveTraversable          #-}
<span class="lineno">   44 </span>{-# LANGUAGE FlexibleContexts           #-}
<span class="lineno">   45 </span>{-# LANGUAGE FlexibleInstances          #-}
<span class="lineno">   46 </span>{-# LANGUAGE GeneralizedNewtypeDeriving #-}
<span class="lineno">   47 </span>{-# LANGUAGE KindSignatures             #-}
<span class="lineno">   48 </span>{-# LANGUAGE LambdaCase                 #-}
<span class="lineno">   49 </span>{-# LANGUAGE MultiParamTypeClasses      #-}
<span class="lineno">   50 </span>{-# LANGUAGE OverloadedStrings          #-}
<span class="lineno">   51 </span>{-# LANGUAGE RecordWildCards            #-}
<span class="lineno">   52 </span>{-# LANGUAGE ScopedTypeVariables        #-}
<span class="lineno">   53 </span>{-# LANGUAGE UndecidableInstances       #-}
<span class="lineno">   54 </span>
<span class="lineno">   55 </span>-- |
<span class="lineno">   56 </span>--   Module      : Language.Ninja.Lexer
<span class="lineno">   57 </span>--   Copyright   : Copyright 2011-2017 Neil Mitchell
<span class="lineno">   58 </span>--   License     : BSD3
<span class="lineno">   59 </span>--   Maintainer  : opensource@awakesecurity.com
<span class="lineno">   60 </span>--   Stability   : experimental
<span class="lineno">   61 </span>--
<span class="lineno">   62 </span>--   Lexing is a slow point, the code below is optimised.
<span class="lineno">   63 </span>--
<span class="lineno">   64 </span>--   @since 0.1.0
<span class="lineno">   65 </span>module Language.Ninja.Lexer
<span class="lineno">   66 </span>  ( -- * Lexing
<span class="lineno">   67 </span>    lexerFile
<span class="lineno">   68 </span>  , lexerText, lexerBS
<span class="lineno">   69 </span>  , lexerText', lexerBS'
<span class="lineno">   70 </span>  , lexemesP
<span class="lineno">   71 </span>  , Parser
<span class="lineno">   72 </span>  , Ann
<span class="lineno">   73 </span>
<span class="lineno">   74 </span>    -- * @Lexeme@ and friends
<span class="lineno">   75 </span>  , Lexeme (..)
<span class="lineno">   76 </span>  , LName  (..)
<span class="lineno">   77 </span>  , LFile  (..)
<span class="lineno">   78 </span>  , LBind  (..)
<span class="lineno">   79 </span>  , LBuild (..), makeLBuild
<span class="lineno">   80 </span>
<span class="lineno">   81 </span>  , LexemeConstraint
<span class="lineno">   82 </span>  , LNameConstraint
<span class="lineno">   83 </span>  , LFileConstraint
<span class="lineno">   84 </span>  , LBindConstraint
<span class="lineno">   85 </span>  , LBuildConstraint
<span class="lineno">   86 </span>
<span class="lineno">   87 </span>    -- * Classes
<span class="lineno">   88 </span>  , PositionParsing (..)
<span class="lineno">   89 </span>  ) where
<span class="lineno">   90 </span>
<span class="lineno">   91 </span>import           Control.Applicative       (Alternative ((&lt;|&gt;)))
<span class="lineno">   92 </span>import           Control.Arrow             (second)
<span class="lineno">   93 </span>import           Control.Monad             (unless, void, when)
<span class="lineno">   94 </span>import           Control.Monad.Error.Class (MonadError)
<span class="lineno">   95 </span>
<span class="lineno">   96 </span>import qualified Control.Lens              as Lens
<span class="lineno">   97 </span>
<span class="lineno">   98 </span>import           Data.ByteString           (ByteString)
<span class="lineno">   99 </span>
<span class="lineno">  100 </span>import           Data.Text                 (Text)
<span class="lineno">  101 </span>import qualified Data.Text                 as Text
<span class="lineno">  102 </span>import qualified Data.Text.Encoding        as Text
<span class="lineno">  103 </span>
<span class="lineno">  104 </span>import           Data.Char                 (isSpace)
<span class="lineno">  105 </span>import           Data.Foldable             (asum)
<span class="lineno">  106 </span>import           Data.Functor              ((&lt;$))
<span class="lineno">  107 </span>import           Data.Maybe                (catMaybes, fromMaybe)
<span class="lineno">  108 </span>
<span class="lineno">  109 </span>import           Flow                      ((.&gt;), (|&gt;))
<span class="lineno">  110 </span>
<span class="lineno">  111 </span>import qualified Text.Megaparsec           as M
<span class="lineno">  112 </span>import qualified Text.Megaparsec.Lexer     as M.Lexer
<span class="lineno">  113 </span>
<span class="lineno">  114 </span>import           Data.Aeson                ((.:), (.=))
<span class="lineno">  115 </span>import qualified Data.Aeson                as Aeson
<span class="lineno">  116 </span>import qualified Data.Aeson.Types          as Aeson
<span class="lineno">  117 </span>
<span class="lineno">  118 </span>import           Control.DeepSeq           (NFData)
<span class="lineno">  119 </span>import           Data.Hashable             (Hashable)
<span class="lineno">  120 </span>import           GHC.Generics              (Generic)
<span class="lineno">  121 </span>
<span class="lineno">  122 </span>import           Test.SmallCheck.Series    ((&lt;~&gt;))
<span class="lineno">  123 </span>import qualified Test.SmallCheck.Series    as SC
<span class="lineno">  124 </span>
<span class="lineno">  125 </span>import           GHC.Exts                  (Constraint)
<span class="lineno">  126 </span>
<span class="lineno">  127 </span>import qualified Language.Ninja.AST        as AST
<span class="lineno">  128 </span>import qualified Language.Ninja.Errors     as Errors
<span class="lineno">  129 </span>import qualified Language.Ninja.Misc       as Misc
<span class="lineno">  130 </span>import qualified Language.Ninja.Mock       as Mock
<span class="lineno">  131 </span>
<span class="lineno">  132 </span>--------------------------------------------------------------------------------
<span class="lineno">  133 </span>
<span class="lineno">  134 </span>-- | The type of annotations returned by the lexer.
<span class="lineno">  135 </span>--
<span class="lineno">  136 </span>--   @since 0.1.0
<span class="lineno">  137 </span>type Ann = Misc.Spans
<span class="lineno">  138 </span>
<span class="lineno">  139 </span>--------------------------------------------------------------------------------
<span class="lineno">  140 </span>
<span class="lineno">  141 </span>-- | Lex each line separately, rather than each lexeme.
<span class="lineno">  142 </span>--
<span class="lineno">  143 </span>--   @since 0.1.0
<span class="lineno">  144 </span>data Lexeme ann
<span class="lineno">  145 </span>  = -- | @foo = bar@
<span class="lineno">  146 </span>    --
<span class="lineno">  147 </span>    --   @since 0.1.0
<span class="lineno">  148 </span>    LexDefine   !ann !(LBind ann)
<span class="lineno">  149 </span>  | -- | @[indent]foo = bar@
<span class="lineno">  150 </span>    --
<span class="lineno">  151 </span>    --   @since 0.1.0
<span class="lineno">  152 </span>    LexBind     !ann !(LBind ann)
<span class="lineno">  153 </span>  | -- | @include file@
<span class="lineno">  154 </span>    --
<span class="lineno">  155 </span>    --   @since 0.1.0
<span class="lineno">  156 </span>    LexInclude  !ann !(LFile ann)
<span class="lineno">  157 </span>  | -- | @subninja file@
<span class="lineno">  158 </span>    --
<span class="lineno">  159 </span>    --   @since 0.1.0
<span class="lineno">  160 </span>    LexSubninja !ann !(LFile ann)
<span class="lineno">  161 </span>  | -- | @build foo: bar | baz || qux@
<span class="lineno">  162 </span>    --
<span class="lineno">  163 </span>    --   @since 0.1.0
<span class="lineno">  164 </span>    LexBuild    !ann !(LBuild ann)
<span class="lineno">  165 </span>  | -- | @rule name@
<span class="lineno">  166 </span>    --
<span class="lineno">  167 </span>    --   @since 0.1.0
<span class="lineno">  168 </span>    LexRule     !ann !(LName ann)
<span class="lineno">  169 </span>  | -- | @pool name@
<span class="lineno">  170 </span>    --
<span class="lineno">  171 </span>    --   @since 0.1.0
<span class="lineno">  172 </span>    LexPool     !ann !(LName ann)
<span class="lineno">  173 </span>  | -- | @default foo bar@
<span class="lineno">  174 </span>    --
<span class="lineno">  175 </span>    --   @since 0.1.0
<span class="lineno">  176 </span>    LexDefault  !ann ![AST.Expr ann]
<span class="lineno">  177 </span>  deriving (<span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span>, Generic, <span class="decl"><span class="istickedoff">Functor</span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Foldable</span></span></span></span>, <span class="decl"><span class="nottickedoff">Traversable</span></span>)
<span class="lineno">  178 </span>
<span class="lineno">  179 </span>-- | The usual definition for 'Misc.Annotated'.
<span class="lineno">  180 </span>--
<span class="lineno">  181 </span>--   @since 0.1.0
<span class="lineno">  182 </span>instance Misc.Annotated Lexeme where
<span class="lineno">  183 </span>  <span class="decl"><span class="nottickedoff">annotation' f = Lens.lens (helper .&gt; fst) (helper .&gt; snd)</span>
<span class="lineno">  184 </span><span class="spaces">    </span><span class="nottickedoff">where</span>
<span class="lineno">  185 </span><span class="spaces">      </span><span class="nottickedoff">helper (LexDefine   ann v) = (ann, \x -&gt; LexDefine   x (f &lt;$&gt; v))</span>
<span class="lineno">  186 </span><span class="spaces">      </span><span class="nottickedoff">helper (LexBind     ann v) = (ann, \x -&gt; LexBind     x (f &lt;$&gt; v))</span>
<span class="lineno">  187 </span><span class="spaces">      </span><span class="nottickedoff">helper (LexInclude  ann v) = (ann, \x -&gt; LexInclude  x (f &lt;$&gt; v))</span>
<span class="lineno">  188 </span><span class="spaces">      </span><span class="nottickedoff">helper (LexSubninja ann v) = (ann, \x -&gt; LexSubninja x (f &lt;$&gt; v))</span>
<span class="lineno">  189 </span><span class="spaces">      </span><span class="nottickedoff">helper (LexBuild    ann v) = (ann, \x -&gt; LexBuild    x (f &lt;$&gt; v))</span>
<span class="lineno">  190 </span><span class="spaces">      </span><span class="nottickedoff">helper (LexRule     ann v) = (ann, \x -&gt; LexRule     x (f &lt;$&gt; v))</span>
<span class="lineno">  191 </span><span class="spaces">      </span><span class="nottickedoff">helper (LexPool     ann v) = (ann, \x -&gt; LexPool     x (f &lt;$&gt; v))</span>
<span class="lineno">  192 </span><span class="spaces">      </span><span class="nottickedoff">helper (LexDefault  ann v) = (ann, \x -&gt; LexDefault  x (map (fmap f) v))</span></span>
<span class="lineno">  193 </span>
<span class="lineno">  194 </span>-- | Converts to @{ann: …, tag: …, value: …}@.
<span class="lineno">  195 </span>--
<span class="lineno">  196 </span>--   @since 0.1.0
<span class="lineno">  197 </span>instance forall ann. (Aeson.ToJSON ann) =&gt; Aeson.ToJSON (Lexeme ann) where
<span class="lineno">  198 </span>  <span class="decl"><span class="istickedoff">toJSON = (\case (LexDefine   ann value) -&gt; <span class="nottickedoff">obj ann &quot;define&quot;   value</span></span>
<span class="lineno">  199 </span><span class="spaces">                  </span><span class="istickedoff">(LexBind     ann value) -&gt; <span class="nottickedoff">obj ann &quot;bind&quot;     value</span></span>
<span class="lineno">  200 </span><span class="spaces">                  </span><span class="istickedoff">(LexInclude  ann value) -&gt; <span class="nottickedoff">obj ann &quot;include&quot;  value</span></span>
<span class="lineno">  201 </span><span class="spaces">                  </span><span class="istickedoff">(LexSubninja ann value) -&gt; <span class="nottickedoff">obj ann &quot;subninja&quot; value</span></span>
<span class="lineno">  202 </span><span class="spaces">                  </span><span class="istickedoff">(LexBuild    ann value) -&gt; <span class="nottickedoff">obj ann &quot;build&quot;    value</span></span>
<span class="lineno">  203 </span><span class="spaces">                  </span><span class="istickedoff">(LexRule     ann value) -&gt; <span class="nottickedoff">obj ann &quot;rule&quot;     value</span></span>
<span class="lineno">  204 </span><span class="spaces">                  </span><span class="istickedoff">(LexPool     ann value) -&gt; <span class="nottickedoff">obj ann &quot;pool&quot;     value</span></span>
<span class="lineno">  205 </span><span class="spaces">                  </span><span class="istickedoff">(LexDefault  ann value) -&gt; obj ann &quot;default&quot;  value)</span>
<span class="lineno">  206 </span><span class="spaces">    </span><span class="istickedoff">where</span>
<span class="lineno">  207 </span><span class="spaces">      </span><span class="istickedoff">obj :: forall x. (Aeson.ToJSON x) =&gt; ann -&gt; Text -&gt; x -&gt; Aeson.Value</span>
<span class="lineno">  208 </span><span class="spaces">      </span><span class="istickedoff">obj ann tag value = [ &quot;ann&quot; .= ann, &quot;tag&quot; .= tag, &quot;value&quot; .= value</span>
<span class="lineno">  209 </span><span class="spaces">                          </span><span class="istickedoff">] |&gt; Aeson.object</span></span>
<span class="lineno">  210 </span>
<span class="lineno">  211 </span>-- | Inverse of the 'Aeson.ToJSON' instance.
<span class="lineno">  212 </span>--
<span class="lineno">  213 </span>--   @since 0.1.0
<span class="lineno">  214 </span>instance (Aeson.FromJSON ann) =&gt; Aeson.FromJSON (Lexeme ann) where
<span class="lineno">  215 </span>  <span class="decl"><span class="istickedoff">parseJSON = (Aeson.withObject <span class="nottickedoff">&quot;Lexeme&quot;</span> $ \o -&gt; do</span>
<span class="lineno">  216 </span><span class="spaces">                  </span><span class="istickedoff">ann &lt;- o .: &quot;ann&quot;</span>
<span class="lineno">  217 </span><span class="spaces">                  </span><span class="istickedoff">tag &lt;- o .: &quot;tag&quot;</span>
<span class="lineno">  218 </span><span class="spaces">                  </span><span class="istickedoff">case (tag :: Text) of</span>
<span class="lineno">  219 </span><span class="spaces">                    </span><span class="istickedoff">&quot;define&quot;   -&gt; <span class="nottickedoff">LexDefine   ann &lt;$&gt; (o .: &quot;value&quot;)</span></span>
<span class="lineno">  220 </span><span class="spaces">                    </span><span class="istickedoff">&quot;bind&quot;     -&gt; <span class="nottickedoff">LexBind     ann &lt;$&gt; (o .: &quot;value&quot;)</span></span>
<span class="lineno">  221 </span><span class="spaces">                    </span><span class="istickedoff">&quot;include&quot;  -&gt; <span class="nottickedoff">LexInclude  ann &lt;$&gt; (o .: &quot;value&quot;)</span></span>
<span class="lineno">  222 </span><span class="spaces">                    </span><span class="istickedoff">&quot;subninja&quot; -&gt; <span class="nottickedoff">LexSubninja ann &lt;$&gt; (o .: &quot;value&quot;)</span></span>
<span class="lineno">  223 </span><span class="spaces">                    </span><span class="istickedoff">&quot;build&quot;    -&gt; <span class="nottickedoff">LexBuild    ann &lt;$&gt; (o .: &quot;value&quot;)</span></span>
<span class="lineno">  224 </span><span class="spaces">                    </span><span class="istickedoff">&quot;rule&quot;     -&gt; <span class="nottickedoff">LexRule     ann &lt;$&gt; (o .: &quot;value&quot;)</span></span>
<span class="lineno">  225 </span><span class="spaces">                    </span><span class="istickedoff">&quot;pool&quot;     -&gt; <span class="nottickedoff">LexPool     ann &lt;$&gt; (o .: &quot;value&quot;)</span></span>
<span class="lineno">  226 </span><span class="spaces">                    </span><span class="istickedoff">&quot;default&quot;  -&gt; LexDefault  ann &lt;$&gt; (o .: &quot;value&quot;)</span>
<span class="lineno">  227 </span><span class="spaces">                    </span><span class="istickedoff">owise      -&gt; <span class="nottickedoff">invalidTagError (Text.unpack owise)</span>)</span>
<span class="lineno">  228 </span><span class="spaces">    </span><span class="istickedoff">where</span>
<span class="lineno">  229 </span><span class="spaces">      </span><span class="istickedoff">invalidTagError :: String -&gt; Aeson.Parser a</span>
<span class="lineno">  230 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">invalidTagError x = [ &quot;Invalid tag: &quot;, x, &quot;; expected one of: &quot;</span></span>
<span class="lineno">  231 </span><span class="spaces">                          </span><span class="istickedoff"><span class="nottickedoff">, show validTags</span></span>
<span class="lineno">  232 </span><span class="spaces">                          </span><span class="istickedoff"><span class="nottickedoff">] |&gt; mconcat |&gt; fail</span></span>
<span class="lineno">  233 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  234 </span><span class="spaces">      </span><span class="istickedoff">validTags :: [Text]</span>
<span class="lineno">  235 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">validTags = [ &quot;define&quot;, &quot;bind&quot;, &quot;include&quot;, &quot;subninja&quot;</span></span>
<span class="lineno">  236 </span><span class="spaces">                  </span><span class="istickedoff"><span class="nottickedoff">, &quot;build&quot;, &quot;rule&quot;, &quot;pool&quot;, &quot;default&quot; ]</span></span></span>
<span class="lineno">  237 </span>
<span class="lineno">  238 </span>-- | Default 'Hashable' instance via 'Generic'.
<span class="lineno">  239 </span>--
<span class="lineno">  240 </span>--   @since 0.1.0
<span class="lineno">  241 </span>instance (Hashable ann) =&gt; Hashable (Lexeme ann)
<span class="lineno">  242 </span>
<span class="lineno">  243 </span>-- | Default 'NFData' instance via 'Generic'.
<span class="lineno">  244 </span>--
<span class="lineno">  245 </span>--   @since 0.1.0
<span class="lineno">  246 </span>instance (NFData ann) =&gt; NFData (Lexeme ann)
<span class="lineno">  247 </span>
<span class="lineno">  248 </span>-- | Default 'SC.Serial' instance via 'Generic'.
<span class="lineno">  249 </span>--
<span class="lineno">  250 </span>--   @since 0.1.0
<span class="lineno">  251 </span>instance ( Monad m, LexemeConstraint (SC.Serial m) ann
<span class="lineno">  252 </span>         ) =&gt; SC.Serial m (Lexeme ann)
<span class="lineno">  253 </span>
<span class="lineno">  254 </span>-- | Default 'SC.CoSerial' instance via 'Generic'.
<span class="lineno">  255 </span>--
<span class="lineno">  256 </span>--   @since 0.1.0
<span class="lineno">  257 </span>instance ( Monad m, LexemeConstraint (SC.CoSerial m) ann
<span class="lineno">  258 </span>         ) =&gt; SC.CoSerial m (Lexeme ann)
<span class="lineno">  259 </span>
<span class="lineno">  260 </span>-- | The set of constraints required for a given constraint to be automatically
<span class="lineno">  261 </span>--   computed for an 'Lexeme'.
<span class="lineno">  262 </span>--
<span class="lineno">  263 </span>--   @since 0.1.0
<span class="lineno">  264 </span>type LexemeConstraint (c :: * -&gt; Constraint) (ann :: *)
<span class="lineno">  265 </span>  = ( LBindConstraint  c ann
<span class="lineno">  266 </span>    , LFileConstraint  c ann
<span class="lineno">  267 </span>    , LBuildConstraint c ann
<span class="lineno">  268 </span>    , LNameConstraint  c ann
<span class="lineno">  269 </span>    , c [AST.Expr ann]
<span class="lineno">  270 </span>    , c ann
<span class="lineno">  271 </span>    )
<span class="lineno">  272 </span>
<span class="lineno">  273 </span>--------------------------------------------------------------------------------
<span class="lineno">  274 </span>
<span class="lineno">  275 </span>-- | The name of a Ninja rule or pool.
<span class="lineno">  276 </span>--
<span class="lineno">  277 </span>--   @since 0.1.0
<span class="lineno">  278 </span>data LName ann
<span class="lineno">  279 </span>  = MkLName
<span class="lineno">  280 </span>    { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_lnameAnn</span></span></span> :: !ann
<span class="lineno">  281 </span>    , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_lnameBS</span></span></span>  :: !ByteString
<span class="lineno">  282 </span>    }
<span class="lineno">  283 </span>  deriving (<span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span>, Generic, <span class="decl"><span class="istickedoff">Functor</span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Foldable</span></span></span></span>, <span class="decl"><span class="nottickedoff">Traversable</span></span>)
<span class="lineno">  284 </span>
<span class="lineno">  285 </span>-- | The usual definition for 'Misc.Annotated'.
<span class="lineno">  286 </span>--
<span class="lineno">  287 </span>--   @since 0.1.0
<span class="lineno">  288 </span>instance Misc.Annotated LName where
<span class="lineno">  289 </span>  <span class="decl"><span class="nottickedoff">annotation' _ = Lens.lens _lnameAnn</span>
<span class="lineno">  290 </span><span class="spaces">                  </span><span class="nottickedoff">$ \(MkLName {..}) x -&gt; MkLName { _lnameAnn = x, .. }</span></span>
<span class="lineno">  291 </span>
<span class="lineno">  292 </span>-- | Converts to @{ann: …, name: …}@.
<span class="lineno">  293 </span>--
<span class="lineno">  294 </span>--   @since 0.1.0
<span class="lineno">  295 </span>instance (Aeson.ToJSON ann) =&gt; Aeson.ToJSON (LName ann) where
<span class="lineno">  296 </span>  <span class="decl"><span class="istickedoff">toJSON (MkLName {..})</span>
<span class="lineno">  297 </span><span class="spaces">    </span><span class="istickedoff">= [ &quot;ann&quot;  .= _lnameAnn</span>
<span class="lineno">  298 </span><span class="spaces">      </span><span class="istickedoff">, &quot;name&quot; .= Text.decodeUtf8 _lnameBS</span>
<span class="lineno">  299 </span><span class="spaces">      </span><span class="istickedoff">] |&gt; Aeson.object</span></span>
<span class="lineno">  300 </span>
<span class="lineno">  301 </span>-- | Inverse of the 'Aeson.ToJSON' instance.
<span class="lineno">  302 </span>--
<span class="lineno">  303 </span>--   @since 0.1.0
<span class="lineno">  304 </span>instance (Aeson.FromJSON ann) =&gt; Aeson.FromJSON (LName ann) where
<span class="lineno">  305 </span>  <span class="decl"><span class="istickedoff">parseJSON = (Aeson.withObject <span class="nottickedoff">&quot;LName&quot;</span> $ \o -&gt; do</span>
<span class="lineno">  306 </span><span class="spaces">                  </span><span class="istickedoff">_lnameAnn &lt;- (o .: &quot;ann&quot;)  &gt;&gt;= pure</span>
<span class="lineno">  307 </span><span class="spaces">                  </span><span class="istickedoff">_lnameBS  &lt;- (o .: &quot;name&quot;) &gt;&gt;= Text.encodeUtf8 .&gt; pure</span>
<span class="lineno">  308 </span><span class="spaces">                  </span><span class="istickedoff">pure (MkLName {..}))</span></span>
<span class="lineno">  309 </span>
<span class="lineno">  310 </span>-- | Default 'Hashable' instance via 'Generic'.
<span class="lineno">  311 </span>--
<span class="lineno">  312 </span>--   @since 0.1.0
<span class="lineno">  313 </span>instance (Hashable ann) =&gt; Hashable (LName ann)
<span class="lineno">  314 </span>
<span class="lineno">  315 </span>-- | Default 'NFData' instance via 'Generic'.
<span class="lineno">  316 </span>--
<span class="lineno">  317 </span>--   @since 0.1.0
<span class="lineno">  318 </span>instance (NFData ann) =&gt; NFData (LName ann)
<span class="lineno">  319 </span>
<span class="lineno">  320 </span>-- | Uses the underlying 'SC.Serial' instances.
<span class="lineno">  321 </span>--
<span class="lineno">  322 </span>--   @since 0.1.0
<span class="lineno">  323 </span>instance ( Monad m, LNameConstraint (SC.Serial m) ann
<span class="lineno">  324 </span>         ) =&gt; SC.Serial m (LName ann) where
<span class="lineno">  325 </span>  <span class="decl"><span class="istickedoff">series = SC.series |&gt; fmap (second Text.encodeUtf8 .&gt; uncurry MkLName)</span></span>
<span class="lineno">  326 </span>
<span class="lineno">  327 </span>-- | Default 'SC.CoSerial' instance via 'Generic'.
<span class="lineno">  328 </span>--
<span class="lineno">  329 </span>--   @since 0.1.0
<span class="lineno">  330 </span>instance ( Monad m, LNameConstraint (SC.CoSerial m) ann
<span class="lineno">  331 </span>         ) =&gt; SC.CoSerial m (LName ann) where
<span class="lineno">  332 </span>  <span class="decl"><span class="nottickedoff">coseries = SC.coseries .&gt; fmap (\f -&gt; _lnameBS .&gt; Text.decodeUtf8 .&gt; f)</span></span>
<span class="lineno">  333 </span>
<span class="lineno">  334 </span>-- | The set of constraints required for a given constraint to be automatically
<span class="lineno">  335 </span>--   computed for an 'LName'.
<span class="lineno">  336 </span>--
<span class="lineno">  337 </span>--   @since 0.1.0
<span class="lineno">  338 </span>type LNameConstraint (c :: * -&gt; Constraint) (ann :: *) = (c Text, c ann)
<span class="lineno">  339 </span>
<span class="lineno">  340 </span>--------------------------------------------------------------------------------
<span class="lineno">  341 </span>
<span class="lineno">  342 </span>-- | A reference to a file in an @include@ or @subninja@ declaration.
<span class="lineno">  343 </span>--
<span class="lineno">  344 </span>--   @since 0.1.0
<span class="lineno">  345 </span>newtype LFile ann
<span class="lineno">  346 </span>  = MkLFile
<span class="lineno">  347 </span>    { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_lfileExpr</span></span></span> :: AST.Expr ann
<span class="lineno">  348 </span>    }
<span class="lineno">  349 </span>  deriving (<span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span>, Generic, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Functor</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Foldable</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff">Traversable</span></span>)
<span class="lineno">  350 </span>
<span class="lineno">  351 </span>-- | Converts to @{file: …}@.
<span class="lineno">  352 </span>--
<span class="lineno">  353 </span>--   @since 0.1.0
<span class="lineno">  354 </span>instance (Aeson.ToJSON ann) =&gt; Aeson.ToJSON (LFile ann) where
<span class="lineno">  355 </span>  <span class="decl"><span class="istickedoff">toJSON (MkLFile {..})</span>
<span class="lineno">  356 </span><span class="spaces">    </span><span class="istickedoff">= [ &quot;file&quot; .= _lfileExpr</span>
<span class="lineno">  357 </span><span class="spaces">      </span><span class="istickedoff">] |&gt; Aeson.object</span></span>
<span class="lineno">  358 </span>
<span class="lineno">  359 </span>-- | Inverse of the 'Aeson.ToJSON' instance.
<span class="lineno">  360 </span>--
<span class="lineno">  361 </span>--   @since 0.1.0
<span class="lineno">  362 </span>instance (Aeson.FromJSON ann) =&gt; Aeson.FromJSON (LFile ann) where
<span class="lineno">  363 </span>  <span class="decl"><span class="istickedoff">parseJSON = (Aeson.withObject <span class="nottickedoff">&quot;LFile&quot;</span> $ \o -&gt; do</span>
<span class="lineno">  364 </span><span class="spaces">                  </span><span class="istickedoff">_lfileExpr &lt;- (o .: &quot;file&quot;)  &gt;&gt;= pure</span>
<span class="lineno">  365 </span><span class="spaces">                  </span><span class="istickedoff">pure (MkLFile {..}))</span></span>
<span class="lineno">  366 </span>
<span class="lineno">  367 </span>-- | Default 'Hashable' instance via 'Generic'.
<span class="lineno">  368 </span>--
<span class="lineno">  369 </span>--   @since 0.1.0
<span class="lineno">  370 </span>instance (Hashable ann) =&gt; Hashable (LFile ann)
<span class="lineno">  371 </span>
<span class="lineno">  372 </span>-- | Default 'NFData' instance via 'Generic'.
<span class="lineno">  373 </span>--
<span class="lineno">  374 </span>--   @since 0.1.0
<span class="lineno">  375 </span>instance (NFData ann) =&gt; NFData (LFile ann)
<span class="lineno">  376 </span>
<span class="lineno">  377 </span>-- | Default 'SC.Serial' instance via 'Generic'.
<span class="lineno">  378 </span>--
<span class="lineno">  379 </span>--   @since 0.1.0
<span class="lineno">  380 </span>instance ( Monad m, LFileConstraint (SC.Serial m) ann
<span class="lineno">  381 </span>         ) =&gt; SC.Serial m (LFile ann)
<span class="lineno">  382 </span>
<span class="lineno">  383 </span>-- | Default 'SC.CoSerial' instance via 'Generic'.
<span class="lineno">  384 </span>--
<span class="lineno">  385 </span>--   @since 0.1.0
<span class="lineno">  386 </span>instance ( Monad m, LFileConstraint (SC.CoSerial m) ann
<span class="lineno">  387 </span>         ) =&gt; SC.CoSerial m (LFile ann)
<span class="lineno">  388 </span>
<span class="lineno">  389 </span>-- | The set of constraints required for a given constraint to be automatically
<span class="lineno">  390 </span>--   computed for an 'LFile'.
<span class="lineno">  391 </span>--
<span class="lineno">  392 </span>--   @since 0.1.0
<span class="lineno">  393 </span>type LFileConstraint (c :: * -&gt; Constraint) (ann :: *) = (c Text, c ann)
<span class="lineno">  394 </span>
<span class="lineno">  395 </span>--------------------------------------------------------------------------------
<span class="lineno">  396 </span>
<span class="lineno">  397 </span>-- | A Ninja variable binding, top-level or otherwise.
<span class="lineno">  398 </span>--
<span class="lineno">  399 </span>--   @since 0.1.0
<span class="lineno">  400 </span>data LBind ann
<span class="lineno">  401 </span>  = MkLBind
<span class="lineno">  402 </span>    { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_lbindAnn</span></span></span>   :: !ann
<span class="lineno">  403 </span>    , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_lbindName</span></span></span>  :: !(LName ann)
<span class="lineno">  404 </span>    , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_lbindValue</span></span></span> :: !(AST.Expr ann)
<span class="lineno">  405 </span>    }
<span class="lineno">  406 </span>  deriving (<span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span>, Generic, <span class="decl"><span class="istickedoff">Functor</span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Foldable</span></span></span></span>, <span class="decl"><span class="nottickedoff">Traversable</span></span>)
<span class="lineno">  407 </span>
<span class="lineno">  408 </span>-- | Converts to @{ann: …, name: …, value: …}@.
<span class="lineno">  409 </span>--
<span class="lineno">  410 </span>--   @since 0.1.0
<span class="lineno">  411 </span>instance (Aeson.ToJSON ann) =&gt; Aeson.ToJSON (LBind ann) where
<span class="lineno">  412 </span>  <span class="decl"><span class="istickedoff">toJSON (MkLBind {..})</span>
<span class="lineno">  413 </span><span class="spaces">    </span><span class="istickedoff">= [ &quot;ann&quot;   .= _lbindAnn</span>
<span class="lineno">  414 </span><span class="spaces">      </span><span class="istickedoff">, &quot;name&quot;  .= _lbindName</span>
<span class="lineno">  415 </span><span class="spaces">      </span><span class="istickedoff">, &quot;value&quot; .= _lbindValue</span>
<span class="lineno">  416 </span><span class="spaces">      </span><span class="istickedoff">] |&gt; Aeson.object</span></span>
<span class="lineno">  417 </span>
<span class="lineno">  418 </span>-- | Inverse of the 'Aeson.ToJSON' instance.
<span class="lineno">  419 </span>--
<span class="lineno">  420 </span>--   @since 0.1.0
<span class="lineno">  421 </span>instance (Aeson.FromJSON ann) =&gt; Aeson.FromJSON (LBind ann) where
<span class="lineno">  422 </span>  <span class="decl"><span class="istickedoff">parseJSON = (Aeson.withObject <span class="nottickedoff">&quot;LBind&quot;</span> $ \o -&gt; do</span>
<span class="lineno">  423 </span><span class="spaces">                  </span><span class="istickedoff">_lbindAnn   &lt;- (o .: &quot;ann&quot;)   &gt;&gt;= pure</span>
<span class="lineno">  424 </span><span class="spaces">                  </span><span class="istickedoff">_lbindName  &lt;- (o .: &quot;name&quot;)  &gt;&gt;= pure</span>
<span class="lineno">  425 </span><span class="spaces">                  </span><span class="istickedoff">_lbindValue &lt;- (o .: &quot;value&quot;) &gt;&gt;= pure</span>
<span class="lineno">  426 </span><span class="spaces">                  </span><span class="istickedoff">pure (MkLBind {..}))</span></span>
<span class="lineno">  427 </span>
<span class="lineno">  428 </span>-- | Default 'Hashable' instance via 'Generic'.
<span class="lineno">  429 </span>--
<span class="lineno">  430 </span>--   @since 0.1.0
<span class="lineno">  431 </span>instance (Hashable ann) =&gt; Hashable (LBind ann)
<span class="lineno">  432 </span>
<span class="lineno">  433 </span>-- | Default 'NFData' instance via 'Generic'.
<span class="lineno">  434 </span>--
<span class="lineno">  435 </span>--   @since 0.1.0
<span class="lineno">  436 </span>instance (NFData ann) =&gt; NFData (LBind ann)
<span class="lineno">  437 </span>
<span class="lineno">  438 </span>-- | Default 'SC.Serial' instance via 'Generic'.
<span class="lineno">  439 </span>--
<span class="lineno">  440 </span>--   @since 0.1.0
<span class="lineno">  441 </span>instance ( Monad m, LBindConstraint (SC.Serial m) ann
<span class="lineno">  442 </span>         ) =&gt; SC.Serial m (LBind ann)
<span class="lineno">  443 </span>
<span class="lineno">  444 </span>-- | Default 'SC.CoSerial' instance via 'Generic'.
<span class="lineno">  445 </span>--
<span class="lineno">  446 </span>--   @since 0.1.0
<span class="lineno">  447 </span>instance ( Monad m, LBindConstraint (SC.CoSerial m) ann
<span class="lineno">  448 </span>         ) =&gt; SC.CoSerial m (LBind ann)
<span class="lineno">  449 </span>
<span class="lineno">  450 </span>-- | The set of constraints required for a given constraint to be automatically
<span class="lineno">  451 </span>--   computed for an 'LBind'.
<span class="lineno">  452 </span>--
<span class="lineno">  453 </span>--   @since 0.1.0
<span class="lineno">  454 </span>type LBindConstraint (c :: * -&gt; Constraint) (ann :: *) = (c Text, c ann)
<span class="lineno">  455 </span>
<span class="lineno">  456 </span>--------------------------------------------------------------------------------
<span class="lineno">  457 </span>
<span class="lineno">  458 </span>-- | The data contained within a Ninja @build@ declaration.
<span class="lineno">  459 </span>--
<span class="lineno">  460 </span>--   @since 0.1.0
<span class="lineno">  461 </span>data LBuild ann
<span class="lineno">  462 </span>  = MkLBuild
<span class="lineno">  463 </span>    { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_lbuildAnn</span></span></span>  :: !ann
<span class="lineno">  464 </span>    , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_lbuildOuts</span></span></span> :: ![AST.Expr ann]
<span class="lineno">  465 </span>    , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_lbuildRule</span></span></span> :: !(LName ann)
<span class="lineno">  466 </span>    , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">_lbuildDeps</span></span></span> :: ![AST.Expr ann]
<span class="lineno">  467 </span>    }
<span class="lineno">  468 </span>  deriving (<span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span>, Generic, <span class="decl"><span class="istickedoff">Functor</span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Foldable</span></span></span></span>, <span class="decl"><span class="nottickedoff">Traversable</span></span>)
<span class="lineno">  469 </span>
<span class="lineno">  470 </span>-- | Constructor for an 'LBuild'.
<span class="lineno">  471 </span>--
<span class="lineno">  472 </span>--   @since 0.1.0
<span class="lineno">  473 </span>makeLBuild :: forall ann.
<span class="lineno">  474 </span>              ann
<span class="lineno">  475 </span>           -- ^ The build annotation
<span class="lineno">  476 </span>           -&gt; [AST.Expr ann]
<span class="lineno">  477 </span>           -- ^ The build outputs
<span class="lineno">  478 </span>           -&gt; LName ann
<span class="lineno">  479 </span>           -- ^ The rule name
<span class="lineno">  480 </span>           -&gt; [AST.Expr ann]
<span class="lineno">  481 </span>           -- ^ The build dependencies
<span class="lineno">  482 </span>           -&gt; LBuild ann
<span class="lineno">  483 </span><span class="decl"><span class="istickedoff">makeLBuild ann outs rule deps</span>
<span class="lineno">  484 </span><span class="spaces">  </span><span class="istickedoff">= let filterExprs :: [AST.Expr ann] -&gt; [AST.Expr ann]</span>
<span class="lineno">  485 </span><span class="spaces">        </span><span class="istickedoff">filterExprs = filter (\case (AST.Lit   _ &quot;&quot;) -&gt; <span class="nottickedoff">False</span></span>
<span class="lineno">  486 </span><span class="spaces">                                    </span><span class="istickedoff">(AST.Exprs _ []) -&gt; <span class="nottickedoff">False</span></span>
<span class="lineno">  487 </span><span class="spaces">                                    </span><span class="istickedoff">_                -&gt; True)</span>
<span class="lineno">  488 </span><span class="spaces">    </span><span class="istickedoff">in MkLBuild ann (filterExprs outs) rule (filterExprs deps)</span></span>
<span class="lineno">  489 </span>
<span class="lineno">  490 </span>-- | The usual definition for 'Misc.Annotated'.
<span class="lineno">  491 </span>--
<span class="lineno">  492 </span>--   @since 0.1.0
<span class="lineno">  493 </span>instance Misc.Annotated LBuild where
<span class="lineno">  494 </span>  <span class="decl"><span class="nottickedoff">annotation' f = Lens.lens _lbuildAnn</span>
<span class="lineno">  495 </span><span class="spaces">                  </span><span class="nottickedoff">$ \(MkLBuild {..}) x -&gt;</span>
<span class="lineno">  496 </span><span class="spaces">                      </span><span class="nottickedoff">MkLBuild { _lbuildAnn = x</span>
<span class="lineno">  497 </span><span class="spaces">                               </span><span class="nottickedoff">, _lbuildOuts = map (fmap f) _lbuildOuts</span>
<span class="lineno">  498 </span><span class="spaces">                               </span><span class="nottickedoff">, _lbuildRule = f &lt;$&gt; _lbuildRule</span>
<span class="lineno">  499 </span><span class="spaces">                               </span><span class="nottickedoff">, _lbuildDeps = map (fmap f) _lbuildOuts</span>
<span class="lineno">  500 </span><span class="spaces">                               </span><span class="nottickedoff">, .. }</span></span>
<span class="lineno">  501 </span>
<span class="lineno">  502 </span>-- | Converts to @{ann: …, outs: …, rule: …, deps: …}@.
<span class="lineno">  503 </span>--
<span class="lineno">  504 </span>--   @since 0.1.0
<span class="lineno">  505 </span>instance (Aeson.ToJSON ann) =&gt; Aeson.ToJSON (LBuild ann) where
<span class="lineno">  506 </span>  <span class="decl"><span class="istickedoff">toJSON (MkLBuild {..})</span>
<span class="lineno">  507 </span><span class="spaces">    </span><span class="istickedoff">= [ &quot;ann&quot;  .= _lbuildAnn</span>
<span class="lineno">  508 </span><span class="spaces">      </span><span class="istickedoff">, &quot;outs&quot; .= _lbuildOuts</span>
<span class="lineno">  509 </span><span class="spaces">      </span><span class="istickedoff">, &quot;rule&quot; .= _lbuildRule</span>
<span class="lineno">  510 </span><span class="spaces">      </span><span class="istickedoff">, &quot;deps&quot; .= _lbuildDeps</span>
<span class="lineno">  511 </span><span class="spaces">      </span><span class="istickedoff">] |&gt; Aeson.object</span></span>
<span class="lineno">  512 </span>
<span class="lineno">  513 </span>-- | Inverse of the 'Aeson.ToJSON' instance.
<span class="lineno">  514 </span>--
<span class="lineno">  515 </span>--   @since 0.1.0
<span class="lineno">  516 </span>instance (Aeson.FromJSON ann) =&gt; Aeson.FromJSON (LBuild ann) where
<span class="lineno">  517 </span>  <span class="decl"><span class="istickedoff">parseJSON = (Aeson.withObject <span class="nottickedoff">&quot;LBuild&quot;</span> $ \o -&gt; do</span>
<span class="lineno">  518 </span><span class="spaces">                  </span><span class="istickedoff">_lbuildAnn  &lt;- (o .: &quot;ann&quot;)  &gt;&gt;= pure</span>
<span class="lineno">  519 </span><span class="spaces">                  </span><span class="istickedoff">_lbuildOuts &lt;- (o .: &quot;outs&quot;) &gt;&gt;= pure</span>
<span class="lineno">  520 </span><span class="spaces">                  </span><span class="istickedoff">_lbuildRule &lt;- (o .: &quot;rule&quot;) &gt;&gt;= pure</span>
<span class="lineno">  521 </span><span class="spaces">                  </span><span class="istickedoff">_lbuildDeps &lt;- (o .: &quot;deps&quot;) &gt;&gt;= pure</span>
<span class="lineno">  522 </span><span class="spaces">                  </span><span class="istickedoff">pure (MkLBuild {..}))</span></span>
<span class="lineno">  523 </span>
<span class="lineno">  524 </span>-- | Default 'Hashable' instance via 'Generic'.
<span class="lineno">  525 </span>--
<span class="lineno">  526 </span>--   @since 0.1.0
<span class="lineno">  527 </span>instance (Hashable ann) =&gt; Hashable (LBuild ann)
<span class="lineno">  528 </span>
<span class="lineno">  529 </span>-- | Default 'NFData' instance via 'Generic'.
<span class="lineno">  530 </span>--
<span class="lineno">  531 </span>--   @since 0.1.0
<span class="lineno">  532 </span>instance (NFData ann) =&gt; NFData (LBuild ann)
<span class="lineno">  533 </span>
<span class="lineno">  534 </span>-- | Uses the underlying 'SC.Serial' instances.
<span class="lineno">  535 </span>--
<span class="lineno">  536 </span>--   @since 0.1.0
<span class="lineno">  537 </span>instance ( Monad m, LBuildConstraint (SC.Serial m) ann
<span class="lineno">  538 </span>         ) =&gt; SC.Serial m (LBuild ann) where
<span class="lineno">  539 </span>  <span class="decl"><span class="istickedoff">series = makeLBuild &lt;$&gt; SC.series &lt;~&gt; SC.series &lt;~&gt; SC.series &lt;~&gt; SC.series</span></span>
<span class="lineno">  540 </span>
<span class="lineno">  541 </span>-- | Default 'SC.CoSerial' instance via 'Generic'.
<span class="lineno">  542 </span>--
<span class="lineno">  543 </span>--   @since 0.1.0
<span class="lineno">  544 </span>instance ( Monad m, LBuildConstraint (SC.CoSerial m) ann
<span class="lineno">  545 </span>         ) =&gt; SC.CoSerial m (LBuild ann)
<span class="lineno">  546 </span>
<span class="lineno">  547 </span>-- | The set of constraints required for a given constraint to be automatically
<span class="lineno">  548 </span>--   computed for an 'LBuild'.
<span class="lineno">  549 </span>--
<span class="lineno">  550 </span>--   @since 0.1.0
<span class="lineno">  551 </span>type LBuildConstraint (c :: * -&gt; Constraint) (ann :: *) = (c Text, c ann)
<span class="lineno">  552 </span>
<span class="lineno">  553 </span>--------------------------------------------------------------------------------
<span class="lineno">  554 </span>
<span class="lineno">  555 </span>-- | Lex the given file.
<span class="lineno">  556 </span>--
<span class="lineno">  557 </span>--   @since 0.1.0
<span class="lineno">  558 </span>lexerFile :: (MonadError Errors.ParseError m, Mock.MonadReadFile m)
<span class="lineno">  559 </span>          =&gt; Misc.Path -&gt; m [Lexeme Ann]
<span class="lineno">  560 </span><span class="decl"><span class="istickedoff">lexerFile file = Mock.readFile file &gt;&gt;= lexerText' (Just file)</span></span>
<span class="lineno">  561 </span>
<span class="lineno">  562 </span>-- | Lex the given 'Text'.
<span class="lineno">  563 </span>--
<span class="lineno">  564 </span>--   @since 0.1.0
<span class="lineno">  565 </span>lexerText :: (MonadError Errors.ParseError m) =&gt; Text -&gt; m [Lexeme Ann]
<span class="lineno">  566 </span><span class="decl"><span class="nottickedoff">lexerText = lexerText' Nothing</span></span>
<span class="lineno">  567 </span>
<span class="lineno">  568 </span>-- | Lex the given 'BSC8.ByteString'.
<span class="lineno">  569 </span>--
<span class="lineno">  570 </span>--   @since 0.1.0
<span class="lineno">  571 </span>lexerBS :: (MonadError Errors.ParseError m) =&gt; ByteString -&gt; m [Lexeme Ann]
<span class="lineno">  572 </span><span class="decl"><span class="istickedoff">lexerBS = lexerBS' Nothing</span></span>
<span class="lineno">  573 </span>
<span class="lineno">  574 </span>-- | Lex the given 'Text' that comes from the given 'Misc.Path', if provided.
<span class="lineno">  575 </span>--
<span class="lineno">  576 </span>--   @since 0.1.0
<span class="lineno">  577 </span>lexerText' :: (MonadError Errors.ParseError m)
<span class="lineno">  578 </span>           =&gt; Maybe Misc.Path -&gt; Text -&gt; m [Lexeme Ann]
<span class="lineno">  579 </span><span class="decl"><span class="istickedoff">lexerText' mp x = let file = fromMaybe &quot;&quot; (Lens.view Misc.pathString &lt;$&gt; mp)</span>
<span class="lineno">  580 </span><span class="spaces">                  </span><span class="istickedoff">in M.runParserT lexemesP file x</span>
<span class="lineno">  581 </span><span class="spaces">                     </span><span class="istickedoff">&gt;&gt;= either <span class="nottickedoff">Errors.throwLexParsecError</span> pure</span></span>
<span class="lineno">  582 </span>
<span class="lineno">  583 </span>-- | Lex the given 'ByteString' that comes from the given 'Misc.Path', if it is
<span class="lineno">  584 </span>--   provided. The 'Misc.Path' is only used for error messages.
<span class="lineno">  585 </span>--
<span class="lineno">  586 </span>--   @since 0.1.0
<span class="lineno">  587 </span>lexerBS' :: (MonadError Errors.ParseError m)
<span class="lineno">  588 </span>         =&gt; Maybe Misc.Path -&gt; ByteString -&gt; m [Lexeme Ann]
<span class="lineno">  589 </span><span class="decl"><span class="istickedoff">lexerBS' mpath = Text.decodeUtf8 .&gt; lexerText' mpath</span></span>
<span class="lineno">  590 </span>
<span class="lineno">  591 </span>--------------------------------------------------------------------------------
<span class="lineno">  592 </span>
<span class="lineno">  593 </span>-- | This class is kind of like 'DeltaParsing' from @trifecta@.
<span class="lineno">  594 </span>--
<span class="lineno">  595 </span>--   @since 0.1.0
<span class="lineno">  596 </span>class (Monad m) =&gt; PositionParsing m where
<span class="lineno">  597 </span>  getPosition :: m Misc.Position
<span class="lineno">  598 </span>
<span class="lineno">  599 </span>-- | Instance for 'M.ParsecT' from @megaparsec@.
<span class="lineno">  600 </span>--
<span class="lineno">  601 </span>--   @since 0.1.0
<span class="lineno">  602 </span>instance PositionParsing (M.ParsecT M.Dec Text m) where
<span class="lineno">  603 </span>  <span class="decl"><span class="istickedoff">getPosition = convert &lt;$&gt; M.getPosition</span>
<span class="lineno">  604 </span><span class="spaces">    </span><span class="istickedoff">where</span>
<span class="lineno">  605 </span><span class="spaces">      </span><span class="istickedoff">convert :: M.SourcePos -&gt; Misc.Position</span>
<span class="lineno">  606 </span><span class="spaces">      </span><span class="istickedoff">convert (M.SourcePos fp line column)</span>
<span class="lineno">  607 </span><span class="spaces">        </span><span class="istickedoff">= let path = Lens.view (Lens.from Misc.pathString) fp</span>
<span class="lineno">  608 </span><span class="spaces">          </span><span class="istickedoff">in Misc.makePosition (Just path) (toLine line, toColumn column)</span>
<span class="lineno">  609 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  610 </span><span class="spaces">      </span><span class="istickedoff">toLine   :: M.Pos -&gt; Misc.Line</span>
<span class="lineno">  611 </span><span class="spaces">      </span><span class="istickedoff">toColumn :: M.Pos -&gt; Misc.Column</span>
<span class="lineno">  612 </span><span class="spaces">      </span><span class="istickedoff">toLine   = M.unPos .&gt; fromIntegral</span>
<span class="lineno">  613 </span><span class="spaces">      </span><span class="istickedoff">toColumn = M.unPos .&gt; fromIntegral</span></span>
<span class="lineno">  614 </span>
<span class="lineno">  615 </span>--------------------------------------------------------------------------------
<span class="lineno">  616 </span>
<span class="lineno">  617 </span>-- | A @megaparsec@ parser.
<span class="lineno">  618 </span>--
<span class="lineno">  619 </span>--   @since 0.1.0
<span class="lineno">  620 </span>type Parser m a = M.ParsecT M.Dec Text m a
<span class="lineno">  621 </span>
<span class="lineno">  622 </span>-- | The @megaparsec@ parser for a Ninja file.
<span class="lineno">  623 </span>--
<span class="lineno">  624 </span>--   @since 0.1.0
<span class="lineno">  625 </span>lexemesP :: Parser m [Lexeme Ann]
<span class="lineno">  626 </span><span class="decl"><span class="istickedoff">lexemesP = do</span>
<span class="lineno">  627 </span><span class="spaces">  </span><span class="istickedoff">maybes &lt;- [ Nothing &lt;$  lineCommentP</span>
<span class="lineno">  628 </span><span class="spaces">            </span><span class="istickedoff">, Nothing &lt;$  M.separatorChar</span>
<span class="lineno">  629 </span><span class="spaces">            </span><span class="istickedoff">, Nothing &lt;$  M.eol</span>
<span class="lineno">  630 </span><span class="spaces">            </span><span class="istickedoff">, Just    &lt;$&gt; (lexemeP &lt;* lineEndP)</span>
<span class="lineno">  631 </span><span class="spaces">            </span><span class="istickedoff">] |&gt; asum |&gt; M.many</span>
<span class="lineno">  632 </span><span class="spaces">  </span><span class="istickedoff">M.eof</span>
<span class="lineno">  633 </span><span class="spaces">  </span><span class="istickedoff">pure (catMaybes maybes)</span></span>
<span class="lineno">  634 </span>
<span class="lineno">  635 </span>--------------------------------------------------------------------------------
<span class="lineno">  636 </span>
<span class="lineno">  637 </span>spanned :: (PositionParsing m) =&gt; m a -&gt; m (Ann, a)
<span class="lineno">  638 </span><span class="decl"><span class="istickedoff">spanned p = do</span>
<span class="lineno">  639 </span><span class="spaces">  </span><span class="istickedoff">start  &lt;- getPosition</span>
<span class="lineno">  640 </span><span class="spaces">  </span><span class="istickedoff">result &lt;- p</span>
<span class="lineno">  641 </span><span class="spaces">  </span><span class="istickedoff">end    &lt;- getPosition</span>
<span class="lineno">  642 </span><span class="spaces">  </span><span class="istickedoff">let getPosFile :: Misc.Position -&gt; Maybe Misc.Path</span>
<span class="lineno">  643 </span><span class="spaces">      </span><span class="istickedoff">getPosFile = Lens.view Misc.positionFile</span>
<span class="lineno">  644 </span><span class="spaces">  </span><span class="istickedoff">let (sfile, efile) = (getPosFile start, getPosFile end)</span>
<span class="lineno">  645 </span><span class="spaces">  </span><span class="istickedoff">when (sfile /= efile) $ <span class="nottickedoff">fail &quot;spanned: somehow went over multiple files!&quot;</span></span>
<span class="lineno">  646 </span><span class="spaces">  </span><span class="istickedoff">let file = sfile</span>
<span class="lineno">  647 </span><span class="spaces">  </span><span class="istickedoff">let offS = Lens.view Misc.positionOffset start</span>
<span class="lineno">  648 </span><span class="spaces">  </span><span class="istickedoff">let offE = Lens.view Misc.positionOffset end</span>
<span class="lineno">  649 </span><span class="spaces">  </span><span class="istickedoff">pure (Misc.makeSpans [Misc.makeSpan file offS offE], result)</span></span>
<span class="lineno">  650 </span>
<span class="lineno">  651 </span>--------------------------------------------------------------------------------
<span class="lineno">  652 </span>
<span class="lineno">  653 </span>lexemeP :: Parser m (Lexeme Ann)
<span class="lineno">  654 </span><span class="decl"><span class="istickedoff">lexemeP = [ includeP, subninjaP, buildP, ruleP, poolP, defaultP, bindP, defineP</span>
<span class="lineno">  655 </span><span class="spaces">          </span><span class="istickedoff">] |&gt; map M.try |&gt; asum</span></span>
<span class="lineno">  656 </span>
<span class="lineno">  657 </span>defineP :: Parser m (Lexeme Ann)
<span class="lineno">  658 </span><span class="decl"><span class="istickedoff">defineP = spanned equationP</span>
<span class="lineno">  659 </span><span class="spaces">          </span><span class="istickedoff">|&gt; fmap (uncurry LexDefine)</span>
<span class="lineno">  660 </span><span class="spaces">          </span><span class="istickedoff">|&gt; debugP <span class="nottickedoff">&quot;defineP&quot;</span></span></span>
<span class="lineno">  661 </span>
<span class="lineno">  662 </span>bindP :: Parser m (Lexeme Ann)
<span class="lineno">  663 </span><span class="decl"><span class="istickedoff">bindP = spanned (indented f)</span>
<span class="lineno">  664 </span><span class="spaces">        </span><span class="istickedoff">|&gt; fmap (uncurry LexBind)</span>
<span class="lineno">  665 </span><span class="spaces">        </span><span class="istickedoff">|&gt; debugP <span class="nottickedoff">&quot;bindP&quot;</span></span>
<span class="lineno">  666 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  667 </span><span class="spaces">    </span><span class="istickedoff">f :: Misc.Column -&gt; Parser m (LBind Ann)</span>
<span class="lineno">  668 </span><span class="spaces">    </span><span class="istickedoff">f x | x &lt; 2 = fail <span class="nottickedoff">&quot;bindP: not indented&quot;</span></span>
<span class="lineno">  669 </span><span class="spaces">    </span><span class="istickedoff">f _         = equationP</span></span>
<span class="lineno">  670 </span>
<span class="lineno">  671 </span>includeP :: Parser m (Lexeme Ann)
<span class="lineno">  672 </span><span class="decl"><span class="istickedoff">includeP = debugP <span class="nottickedoff">&quot;includeP&quot;</span> $ do</span>
<span class="lineno">  673 </span><span class="spaces">  </span><span class="istickedoff">(ann, file) &lt;- spanned $ do</span>
<span class="lineno">  674 </span><span class="spaces">    </span><span class="istickedoff">beginningOfLine</span>
<span class="lineno">  675 </span><span class="spaces">    </span><span class="istickedoff">symbolP &quot;include&quot;</span>
<span class="lineno">  676 </span><span class="spaces">    </span><span class="istickedoff">M.Lexer.lexeme spaceP fileP</span>
<span class="lineno">  677 </span><span class="spaces">  </span><span class="istickedoff">pure (LexInclude ann file)</span></span>
<span class="lineno">  678 </span>
<span class="lineno">  679 </span>subninjaP :: Parser m (Lexeme Ann)
<span class="lineno">  680 </span><span class="decl"><span class="istickedoff">subninjaP = debugP <span class="nottickedoff">&quot;subninjaP&quot;</span> $ do</span>
<span class="lineno">  681 </span><span class="spaces">  </span><span class="istickedoff">(ann, file) &lt;- spanned $ do</span>
<span class="lineno">  682 </span><span class="spaces">    </span><span class="istickedoff">beginningOfLine</span>
<span class="lineno">  683 </span><span class="spaces">    </span><span class="istickedoff">symbolP &quot;subninja&quot;</span>
<span class="lineno">  684 </span><span class="spaces">    </span><span class="istickedoff">M.Lexer.lexeme spaceP fileP</span>
<span class="lineno">  685 </span><span class="spaces">  </span><span class="istickedoff">pure (LexSubninja ann file)</span></span>
<span class="lineno">  686 </span>
<span class="lineno">  687 </span>buildP :: Parser m (Lexeme Ann)
<span class="lineno">  688 </span><span class="decl"><span class="istickedoff">buildP = debugP <span class="nottickedoff">&quot;buildP&quot;</span> $ do</span>
<span class="lineno">  689 </span><span class="spaces">  </span><span class="istickedoff">let isExprEmpty :: AST.Expr Ann -&gt; Bool</span>
<span class="lineno">  690 </span><span class="spaces">      </span><span class="istickedoff">isExprEmpty (AST.Lit   _ &quot;&quot;) = <span class="nottickedoff">True</span></span>
<span class="lineno">  691 </span><span class="spaces">      </span><span class="istickedoff">isExprEmpty (AST.Exprs _ []) = <span class="nottickedoff">True</span></span>
<span class="lineno">  692 </span><span class="spaces">      </span><span class="istickedoff">isExprEmpty _                = False</span>
<span class="lineno">  693 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  694 </span><span class="spaces">  </span><span class="istickedoff">let cleanExprs :: [AST.Expr Ann] -&gt; [AST.Expr Ann]</span>
<span class="lineno">  695 </span><span class="spaces">      </span><span class="istickedoff">cleanExprs = map AST.normalizeExpr .&gt; filter (isExprEmpty .&gt; not)</span>
<span class="lineno">  696 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  697 </span><span class="spaces">  </span><span class="istickedoff">(ann, (outs, rule, deps)) &lt;- spanned $ do</span>
<span class="lineno">  698 </span><span class="spaces">    </span><span class="istickedoff">beginningOfLine</span>
<span class="lineno">  699 </span><span class="spaces">    </span><span class="istickedoff">symbolP &quot;build&quot;</span>
<span class="lineno">  700 </span><span class="spaces">    </span><span class="istickedoff">outs &lt;- cleanExprs &lt;$&gt; M.some outputP</span>
<span class="lineno">  701 </span><span class="spaces">    </span><span class="istickedoff">symbolP &quot;:&quot;</span>
<span class="lineno">  702 </span><span class="spaces">    </span><span class="istickedoff">rule &lt;- nameP</span>
<span class="lineno">  703 </span><span class="spaces">    </span><span class="istickedoff">deps &lt;- cleanExprs &lt;$&gt; M.many (M.Lexer.lexeme spaceP exprP)</span>
<span class="lineno">  704 </span><span class="spaces">    </span><span class="istickedoff">pure (outs, rule, deps)</span>
<span class="lineno">  705 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  706 </span><span class="spaces">  </span><span class="istickedoff">pure (LexBuild ann (MkLBuild ann outs rule deps))</span></span>
<span class="lineno">  707 </span>
<span class="lineno">  708 </span>ruleP :: Parser m (Lexeme Ann)
<span class="lineno">  709 </span><span class="decl"><span class="istickedoff">ruleP = debugP <span class="nottickedoff">&quot;ruleP&quot;</span> $ do</span>
<span class="lineno">  710 </span><span class="spaces">  </span><span class="istickedoff">(ann, ruleName) &lt;- spanned $ do</span>
<span class="lineno">  711 </span><span class="spaces">    </span><span class="istickedoff">beginningOfLine</span>
<span class="lineno">  712 </span><span class="spaces">    </span><span class="istickedoff">symbolP &quot;rule&quot;</span>
<span class="lineno">  713 </span><span class="spaces">    </span><span class="istickedoff">nameP</span>
<span class="lineno">  714 </span><span class="spaces">  </span><span class="istickedoff">pure (LexRule ann ruleName)</span></span>
<span class="lineno">  715 </span>
<span class="lineno">  716 </span>poolP :: Parser m (Lexeme Ann)
<span class="lineno">  717 </span><span class="decl"><span class="istickedoff">poolP = debugP <span class="nottickedoff">&quot;poolP&quot;</span> $ do</span>
<span class="lineno">  718 </span><span class="spaces">  </span><span class="istickedoff">(ann, poolName) &lt;- spanned $ do</span>
<span class="lineno">  719 </span><span class="spaces">    </span><span class="istickedoff">beginningOfLine</span>
<span class="lineno">  720 </span><span class="spaces">    </span><span class="istickedoff">symbolP &quot;pool&quot;</span>
<span class="lineno">  721 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">nameP</span></span>
<span class="lineno">  722 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">pure (LexPool ann poolName)</span></span></span>
<span class="lineno">  723 </span>
<span class="lineno">  724 </span>defaultP :: Parser m (Lexeme Ann)
<span class="lineno">  725 </span><span class="decl"><span class="istickedoff">defaultP = debugP <span class="nottickedoff">&quot;defaultP&quot;</span> $ do</span>
<span class="lineno">  726 </span><span class="spaces">  </span><span class="istickedoff">(ann, defaults) &lt;- spanned $ do</span>
<span class="lineno">  727 </span><span class="spaces">    </span><span class="istickedoff">beginningOfLine</span>
<span class="lineno">  728 </span><span class="spaces">    </span><span class="istickedoff">symbolP &quot;default&quot;</span>
<span class="lineno">  729 </span><span class="spaces">    </span><span class="istickedoff">M.many (M.Lexer.lexeme spaceP exprP)</span>
<span class="lineno">  730 </span><span class="spaces">  </span><span class="istickedoff">pure (LexDefault ann defaults)</span></span>
<span class="lineno">  731 </span>
<span class="lineno">  732 </span>lineEndP :: Parser m ()
<span class="lineno">  733 </span><span class="decl"><span class="istickedoff">lineEndP = do</span>
<span class="lineno">  734 </span><span class="spaces">  </span><span class="istickedoff">M.many M.separatorChar</span>
<span class="lineno">  735 </span><span class="spaces">  </span><span class="istickedoff">lineCommentP &lt;|&gt; pure <span class="nottickedoff">()</span></span>
<span class="lineno">  736 </span><span class="spaces">  </span><span class="istickedoff">void M.eol</span></span>
<span class="lineno">  737 </span>
<span class="lineno">  738 </span>equationP :: Parser m (LBind Ann)
<span class="lineno">  739 </span><span class="decl"><span class="istickedoff">equationP = debugP <span class="nottickedoff">&quot;equationP&quot;</span> $ do</span>
<span class="lineno">  740 </span><span class="spaces">  </span><span class="istickedoff">(ann, (name, value)) &lt;- spanned $ do</span>
<span class="lineno">  741 </span><span class="spaces">    </span><span class="istickedoff">name &lt;- nameP</span>
<span class="lineno">  742 </span><span class="spaces">    </span><span class="istickedoff">symbolP &quot;=&quot;</span>
<span class="lineno">  743 </span><span class="spaces">    </span><span class="istickedoff">value &lt;- exprsP</span>
<span class="lineno">  744 </span><span class="spaces">    </span><span class="istickedoff">pure (name, value)</span>
<span class="lineno">  745 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  746 </span><span class="spaces">  </span><span class="istickedoff">pure (MkLBind ann name value)</span></span>
<span class="lineno">  747 </span>
<span class="lineno">  748 </span>nameP :: Parser m (LName Ann)
<span class="lineno">  749 </span><span class="decl"><span class="istickedoff">nameP = spanned varDotP</span>
<span class="lineno">  750 </span><span class="spaces">        </span><span class="istickedoff">|&gt; fmap (second (Text.pack .&gt; Text.encodeUtf8) .&gt; uncurry MkLName)</span>
<span class="lineno">  751 </span><span class="spaces">        </span><span class="istickedoff">|&gt; M.Lexer.lexeme spaceP</span>
<span class="lineno">  752 </span><span class="spaces">        </span><span class="istickedoff">|&gt; debugP <span class="nottickedoff">&quot;nameP&quot;</span></span></span>
<span class="lineno">  753 </span>
<span class="lineno">  754 </span>fileP :: Parser m (LFile Ann)
<span class="lineno">  755 </span><span class="decl"><span class="istickedoff">fileP = MkLFile &lt;$&gt; exprP</span>
<span class="lineno">  756 </span><span class="spaces">        </span><span class="istickedoff">|&gt; M.Lexer.lexeme spaceP</span>
<span class="lineno">  757 </span><span class="spaces">        </span><span class="istickedoff">|&gt; debugP <span class="nottickedoff">&quot;fileP&quot;</span></span></span>
<span class="lineno">  758 </span>
<span class="lineno">  759 </span>outputP :: Parser m (AST.Expr Ann)
<span class="lineno">  760 </span><span class="decl"><span class="istickedoff">outputP = spanned (M.some (dollarP &lt;|&gt; litP))</span>
<span class="lineno">  761 </span><span class="spaces">          </span><span class="istickedoff">|&gt; fmap (uncurry AST.Exprs .&gt; AST.normalizeExpr)</span>
<span class="lineno">  762 </span><span class="spaces">          </span><span class="istickedoff">|&gt; M.Lexer.lexeme spaceP</span>
<span class="lineno">  763 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  764 </span><span class="spaces">    </span><span class="istickedoff">litP :: Parser m (AST.Expr Ann)</span>
<span class="lineno">  765 </span><span class="spaces">    </span><span class="istickedoff">litP = spanned (M.some (M.satisfy isOutputChar))</span>
<span class="lineno">  766 </span><span class="spaces">           </span><span class="istickedoff">|&gt; fmap (second Text.pack .&gt; uncurry AST.Lit)</span>
<span class="lineno">  767 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  768 </span><span class="spaces">    </span><span class="istickedoff">isOutputChar :: Char -&gt; Bool</span>
<span class="lineno">  769 </span><span class="spaces">    </span><span class="istickedoff">isOutputChar '$'             = False</span>
<span class="lineno">  770 </span><span class="spaces">    </span><span class="istickedoff">isOutputChar ':'             = False</span>
<span class="lineno">  771 </span><span class="spaces">    </span><span class="istickedoff">isOutputChar '\n'            = False</span>
<span class="lineno">  772 </span><span class="spaces">    </span><span class="istickedoff">isOutputChar '\r'            = <span class="nottickedoff">False</span></span>
<span class="lineno">  773 </span><span class="spaces">    </span><span class="istickedoff">isOutputChar c   | isSpace c = False</span>
<span class="lineno">  774 </span><span class="spaces">    </span><span class="istickedoff">isOutputChar _               = True</span></span>
<span class="lineno">  775 </span>
<span class="lineno">  776 </span>exprsP :: Parser m (AST.Expr Ann)
<span class="lineno">  777 </span><span class="decl"><span class="istickedoff">exprsP = asum [exprP, separatorP]</span>
<span class="lineno">  778 </span><span class="spaces">         </span><span class="istickedoff">|&gt; M.many |&gt; spanned |&gt; fmap (uncurry AST.Exprs .&gt; AST.normalizeExpr)</span>
<span class="lineno">  779 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  780 </span><span class="spaces">    </span><span class="istickedoff">separatorP :: Parser m (AST.Expr Ann)</span>
<span class="lineno">  781 </span><span class="spaces">    </span><span class="istickedoff">separatorP = spanned (M.some M.separatorChar)</span>
<span class="lineno">  782 </span><span class="spaces">                 </span><span class="istickedoff">|&gt; fmap (second Text.pack .&gt; uncurry AST.Lit)</span></span>
<span class="lineno">  783 </span>
<span class="lineno">  784 </span>exprP :: Parser m (AST.Expr Ann)
<span class="lineno">  785 </span><span class="decl"><span class="istickedoff">exprP = spanned (M.some (dollarP &lt;|&gt; litP))</span>
<span class="lineno">  786 </span><span class="spaces">        </span><span class="istickedoff">|&gt; fmap (uncurry AST.Exprs .&gt; AST.normalizeExpr)</span>
<span class="lineno">  787 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  788 </span><span class="spaces">    </span><span class="istickedoff">litP :: Parser m (AST.Expr Ann)</span>
<span class="lineno">  789 </span><span class="spaces">    </span><span class="istickedoff">litP = spanned (M.some (M.satisfy isExprChar))</span>
<span class="lineno">  790 </span><span class="spaces">           </span><span class="istickedoff">|&gt; fmap (second Text.pack .&gt; uncurry AST.Lit)</span>
<span class="lineno">  791 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  792 </span><span class="spaces">    </span><span class="istickedoff">isExprChar :: Char -&gt; Bool</span>
<span class="lineno">  793 </span><span class="spaces">    </span><span class="istickedoff">isExprChar '$'             = False</span>
<span class="lineno">  794 </span><span class="spaces">    </span><span class="istickedoff">isExprChar '\n'            = False</span>
<span class="lineno">  795 </span><span class="spaces">    </span><span class="istickedoff">isExprChar '\r'            = <span class="nottickedoff">False</span></span>
<span class="lineno">  796 </span><span class="spaces">    </span><span class="istickedoff">isExprChar c   | isSpace c = False</span>
<span class="lineno">  797 </span><span class="spaces">    </span><span class="istickedoff">isExprChar _               = True</span></span>
<span class="lineno">  798 </span>
<span class="lineno">  799 </span>dollarP :: Parser m (AST.Expr Ann)
<span class="lineno">  800 </span><span class="decl"><span class="istickedoff">dollarP = debugP <span class="nottickedoff">&quot;dollarP&quot;</span></span>
<span class="lineno">  801 </span><span class="spaces">          </span><span class="istickedoff">(M.char '$'</span>
<span class="lineno">  802 </span><span class="spaces">           </span><span class="istickedoff">*&gt; ([ makeLit (M.string &quot;$&quot;)</span>
<span class="lineno">  803 </span><span class="spaces">               </span><span class="istickedoff">, makeLit (M.string &quot; &quot;)</span>
<span class="lineno">  804 </span><span class="spaces">               </span><span class="istickedoff">, makeLit (M.string &quot;:&quot;)</span>
<span class="lineno">  805 </span><span class="spaces">               </span><span class="istickedoff">, makeLit ((M.eol *&gt; M.many M.separatorChar *&gt; pure &quot;&quot;))</span>
<span class="lineno">  806 </span><span class="spaces">               </span><span class="istickedoff">, makeVar ((M.char '{' *&gt; varDotP &lt;* M.char '}'))</span>
<span class="lineno">  807 </span><span class="spaces">               </span><span class="istickedoff">, makeVar varP</span>
<span class="lineno">  808 </span><span class="spaces">               </span><span class="istickedoff">] |&gt; asum))</span>
<span class="lineno">  809 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  810 </span><span class="spaces">    </span><span class="istickedoff">makeLit, makeVar :: Parser m String -&gt; Parser m (AST.Expr Ann)</span>
<span class="lineno">  811 </span><span class="spaces">    </span><span class="istickedoff">makeLit p = spanned p |&gt; fmap (second Text.pack .&gt; uncurry AST.Lit)</span>
<span class="lineno">  812 </span><span class="spaces">    </span><span class="istickedoff">makeVar p = spanned p |&gt; fmap (second Text.pack .&gt; uncurry AST.Var)</span></span>
<span class="lineno">  813 </span>
<span class="lineno">  814 </span>varDotP :: Parser m String
<span class="lineno">  815 </span><span class="decl"><span class="istickedoff">varDotP = M.some (M.alphaNumChar &lt;|&gt; M.oneOf ['/', '-', '_', '.'])</span>
<span class="lineno">  816 </span><span class="spaces">          </span><span class="istickedoff">|&gt; debugP <span class="nottickedoff">&quot;varDotP&quot;</span></span></span>
<span class="lineno">  817 </span>
<span class="lineno">  818 </span>varP :: Parser m String
<span class="lineno">  819 </span><span class="decl"><span class="istickedoff">varP = M.some (M.alphaNumChar &lt;|&gt; M.oneOf ['/', '-', '_'])</span>
<span class="lineno">  820 </span><span class="spaces">       </span><span class="istickedoff">|&gt; debugP <span class="nottickedoff">&quot;varP&quot;</span></span></span>
<span class="lineno">  821 </span>
<span class="lineno">  822 </span>symbolP :: String -&gt; Parser m String
<span class="lineno">  823 </span><span class="decl"><span class="istickedoff">symbolP = M.Lexer.symbol spaceP</span></span>
<span class="lineno">  824 </span>
<span class="lineno">  825 </span>spaceP :: Parser m ()
<span class="lineno">  826 </span><span class="decl"><span class="istickedoff">spaceP = M.Lexer.space (void M.separatorChar) lineCommentP blockCommentP</span></span>
<span class="lineno">  827 </span>
<span class="lineno">  828 </span>lineCommentP :: Parser m ()
<span class="lineno">  829 </span><span class="decl"><span class="istickedoff">lineCommentP = M.Lexer.skipLineComment &quot;#&quot;</span></span>
<span class="lineno">  830 </span>
<span class="lineno">  831 </span>blockCommentP :: Parser m ()
<span class="lineno">  832 </span><span class="decl"><span class="istickedoff">blockCommentP = fail <span class="nottickedoff">&quot;always&quot;</span></span></span>
<span class="lineno">  833 </span>
<span class="lineno">  834 </span>indented :: (Misc.Column -&gt; Parser m a) -&gt; Parser m a
<span class="lineno">  835 </span><span class="decl"><span class="istickedoff">indented f = do</span>
<span class="lineno">  836 </span><span class="spaces">  </span><span class="istickedoff">M.many M.separatorChar</span>
<span class="lineno">  837 </span><span class="spaces">  </span><span class="istickedoff">getPosition &gt;&gt;= Lens.view Misc.positionCol .&gt; f</span></span>
<span class="lineno">  838 </span>
<span class="lineno">  839 </span>beginningOfLine :: Parser m ()
<span class="lineno">  840 </span><span class="decl"><span class="istickedoff">beginningOfLine = do</span>
<span class="lineno">  841 </span><span class="spaces">  </span><span class="istickedoff">col &lt;- Lens.view Misc.positionCol &lt;$&gt; getPosition</span>
<span class="lineno">  842 </span><span class="spaces">  </span><span class="istickedoff">unless (col == 1) (fail <span class="nottickedoff">&quot;beginningOfLine failed&quot;</span>)</span></span>
<span class="lineno">  843 </span>
<span class="lineno">  844 </span>debugP :: (Show a) =&gt; String -&gt; Parser m a -&gt; Parser m a
<span class="lineno">  845 </span><span class="decl"><span class="istickedoff">debugP str p = M.label <span class="nottickedoff">str</span> p -- M.dbg str p</span>
<span class="lineno">  846 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  847 </span><span class="spaces">    </span><span class="istickedoff">-- this shuts up the compiler wrt the Show constraint</span>
<span class="lineno">  848 </span><span class="spaces">    </span><span class="istickedoff">_ = <span class="nottickedoff">show &lt;$&gt; p</span></span></span>
<span class="lineno">  849 </span>
<span class="lineno">  850 </span>--------------------------------------------------------------------------------

</pre>
</body>
</html>
